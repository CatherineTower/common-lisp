(in-package :umbra.noise)

;;;; Noise functions
;;;; Cellular noise

(defun-gpu cellular-weight-samples ((samples :vec4))
  (let ((samples (1- (* samples 2))))
    (- (* samples samples samples) (sign samples))))

(defun-gpu cellular ((p :vec2)
                     (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (jitter-window 0.25)
         ((dx :vec4))
         ((dy :vec4))
         ((d :vec4)))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (setf x (+ (* (cellular-weight-samples x) jitter-window) (vec4 0 1 0 1))
            y (+ (* (cellular-weight-samples y) jitter-window) (vec4 0 0 1 1))
            dx (- (.x pf) x)
            dy (- (.y pf) y)
            d (+ (* dx dx) (* dy dy))
            (.xy d) (min (.xy d) (.zw d)))
      (* (min (.x d) (.y d)) (/ 1.125)))))

(defun-gpu cellular ((p :vec2))
  (cellular p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu cellular/fast ((p :vec2)
                          (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (jitter-window 0.4)
         ((dx :vec4))
         ((dy :vec4))
         ((d :vec4)))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (setf x (+ (* x jitter-window 2)
                 (vec4 (- jitter-window) (- 1 jitter-window) (- jitter-window) (- 1 jitter-window)))
            y (+ (* y jitter-window 2)
                 (vec4 (- jitter-window) (- jitter-window) (- 1 jitter-window) (- 1 jitter-window)))
            dx (- (.x pf) x)
            dy (- (.y pf) y)
            d (+ (* dx dx) (* dy dy))
            (.xy d) (min (.xy d) (.zw d)))
      (* (min (.x d) (.y d)) (/ 1.125)))))

(defun-gpu cellular/fast ((p :vec2))
  (cellular/fast p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu cellular/simplex ((p :vec2)
                             (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((jitter-window (* 0.105662435 +simplex-2d/inverse-triangle-height+))
         (simplex-points (* (vec3 (- 1 +simplex-2d/unskew-factor+)
                                  (- +simplex-2d/unskew-factor+)
                                  (- 1 (* 2 +simplex-2d/unskew-factor+)))
                            +simplex-2d/inverse-triangle-height+))
         (p (* p +simplex-2d/triangle-height+))
         (pi (floor (+ p (dot p (vec2 +simplex-2d/skew-factor+)))))
         (p0 (* (- pi (dot pi (vec2 +simplex-2d/unskew-factor+)) p)
                +simplex-2d/inverse-triangle-height+)))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (setf x (+ (* (cellular-weight-samples x) jitter-window) (.x p0))
            y (+ (* (cellular-weight-samples y) jitter-window) (.y p0)))
      (incf (.yzw x) (.xyz simplex-points))
      (incf (.yzw y) (.yxz simplex-points))
      (let* ((dist-sq (+ (* x x) (* y y)))
             (temp (min (.xy dist-sq) (.zw dist-sq))))
        (min (.x temp) (.y temp))))))

(defun-gpu cellular/simplex ((p :vec2))
  (cellular/simplex p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu cellular ((p :vec3)
                     (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (jitter-window (/ 6.0))
         ((dx1 :vec4))
         ((dy1 :vec4))
         ((dz1 :vec4))
         ((dx2 :vec4))
         ((dy2 :vec4))
         ((dz2 :vec4))
         ((d1 :vec4))
         ((d2 :vec4)))
    (multiple-value-bind (x0 y0 z0 x1 y1 z1) (funcall hash-fn pi)
      (setf x0 (+ (* (cellular-weight-samples x0) jitter-window) (vec4 0 1 0 1))
            y0 (+ (* (cellular-weight-samples y0) jitter-window) (vec4 0 0 1 1))
            z0 (* (cellular-weight-samples z0) jitter-window)
            x1 (+ (* (cellular-weight-samples x1) jitter-window) (vec4 0 1 0 1))
            y1 (+ (* (cellular-weight-samples y1) jitter-window) (vec4 0 0 1 1))
            z1 (+ (* (cellular-weight-samples z1) jitter-window) 1)
            dx1 (- (.x pf) x0)
            dy1 (- (.y pf) y0)
            dz1 (- (.z pf) z0)
            dx2 (- (.x pf) x1)
            dy2 (- (.y pf) y1)
            dz2 (- (.z pf) z1)
            d2 (+ (* dx2 dx2) (* dy2 dy2) (* dz2 dz2))
            d1 (min (+ (* dx1 dx1) (* dy1 dy1) (* dz1 dz1)) d2)
            (.xy d1) (min (.xy d1) (.wz d1)))
      (* (min (.x d1) (.y d1)) (/ 9 12.0)))))

(defun-gpu cellular ((p :vec3))
  (cellular p (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu cellular/fast ((p :vec3)
                          (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (jitter-window 0.4)
         ((dx1 :vec4))
         ((dy1 :vec4))
         ((dz1 :vec4))
         ((dx2 :vec4))
         ((dy2 :vec4))
         ((dz2 :vec4))
         ((d1 :vec4))
         ((d2 :vec4)))
    (multiple-value-bind (x0 y0 z0 x1 y1 z1) (funcall hash-fn pi)
      (setf x0 (+ (* x0 jitter-window 2)
                  (vec4 (- jitter-window) (- 1 jitter-window) (- jitter-window) (- 1 jitter-window)))
            y0 (+ (* y0 jitter-window 2)
                  (vec4 (- jitter-window) (- jitter-window) (- 1 jitter-window) (- 1 jitter-window)))
            z0 (+ (* z0 jitter-window 2) (- jitter-window))
            x1 (+ (* x1 jitter-window 2)
                  (vec4 (- jitter-window) (- 1 jitter-window) (- jitter-window) (- 1 jitter-window)))
            y1 (+ (* y1 jitter-window 2)
                  (vec4 (- jitter-window) (- jitter-window) (- 1 jitter-window) (- 1 jitter-window)))
            z1 (+ (* z0 jitter-window 2) (- 1 jitter-window))
            dx1 (- (.x pf) x0)
            dy1 (- (.y pf) y0)
            dz1 (- (.z pf) z0)
            dx2 (- (.x pf) x1)
            dy2 (- (.y pf) y1)
            dz2 (- (.z pf) z1)
            d2 (+ (* dx2 dx2) (* dy2 dy2) (* dz2 dz2))
            d1 (min (+ (* dx1 dx1) (* dy1 dy1) (* dz1 dz1)) d2)
            (.xy d1) (min (.xy d1) (.wz d1)))
      (* (min (.x d1) (.y d1)) (/ 9 12.0)))))

(defun-gpu cellular/fast ((p :vec3))
  (cellular/fast p (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))
