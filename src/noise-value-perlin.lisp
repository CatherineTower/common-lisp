(in-package :umbra.noise)

;;;; Noise functions
;;;; Value Perlin noise
;;;; A uniform blend between value and perlin noise

(defconstant +value-perlin/scale+ (/ (sqrt 0.5)))

(defun-gpu value-perlin ((p :vec2)
                         (blend-value :float)
                         (hash-fn (function (:vec2) (:vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (hash x y) (funcall hash-fn pi)
      (let* ((grad-x (- x 0.49999))
             (grad-y (- y 0.49999))
             (grad-results (mix (1- (* hash 2))
                                (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                                   (+ (* grad-x (.xzxz pf-pfmin1))
                                      (* grad-y (.yyww pf-pfmin1)))
                                   +value-perlin/scale+)
                                blend-value))
             (blend (umbra.shaping:quintic-curve (.xy pf-pfmin1)))
             (blend2 (vec4 blend (- 1 blend))))
        (map-domain
         (dot grad-results (* (.zxzx blend2) (.wwyy blend2)))
         -1 1 0 1)))))

(defun-gpu value-perlin ((p :vec2)
                         (blend-value :float))
  (value-perlin p blend-value (lambda ((x :vec2)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu value-perlin ((p :vec3)
                         (blend-value :float)
                         (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4
                                                     :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (hash0 x0 y0 z0 hash1 x1 y1 z1) (funcall hash-fn pi)
      (let* ((grad-x0 (- x0 0.49999))
             (grad-y0 (- y0 0.49999))
             (grad-z0 (- z0 0.49999))
             (grad-x1 (- x1 0.49999))
             (grad-y1 (- y1 0.49999))
             (grad-z1 (- z1 0.49999))
             (grad-results0 (mix (1- (* hash0 2))
                                 (* (inversesqrt (+ (* grad-x0 grad-x0)
                                                    (* grad-y0 grad-y0)
                                                    (* grad-z0 grad-z0)))
                                    (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x0)
                                       (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y0)
                                       (* (.z pf) grad-z0))
                                    +perlin/scale+)
                                 blend-value))
             (grad-results1 (mix (1- (* hash1 2))
                                 (* (inversesqrt (+ (* grad-x1 grad-x1)
                                                    (* grad-y1 grad-y1)
                                                    (* grad-z1 grad-z1)))
                                    (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x1)
                                       (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y1)
                                       (* (.z pf-min1) grad-z1))
                                    +perlin/scale+)
                                 blend-value))
             (blend (umbra.shaping:quintic-curve pf))
             (res0 (mix grad-results0 grad-results1 (.z blend)))
             (blend2 (vec4 (.xy blend) (- 1 (.xy blend)))))
        (map-domain
         (dot res0 (* (.zxzx blend2) (.wwyy blend2)))
         -1 1 0 1)))))

(defun-gpu value-perlin ((p :vec3)
                         (blend-value :float))
  (value-perlin p blend-value (lambda ((x :vec3)) (umbra.hashing:fast32/4-per-corner x))))
