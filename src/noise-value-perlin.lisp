(in-package :umbra.noise)

;;;; Noise functions
;;;; Value Perlin noise
;;;; A uniform blend between value and perlin noise

(defun-gpu value-perlin ((point :vec2)
                         (blend-value :float)
                         (hash-fn (function (:vec2) (:vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vecs (- (.xyxy point) (vec4 cell (1+ cell))))
           (hash hash-x hash-y (funcall hash-fn cell))
           (grad-x (- hash-x 0.5 +epsilon+))
           (grad-y (- hash-y 0.5 +epsilon+))
           (grad-results (mix (1- (* hash 2))
                              (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                                 (+ (* grad-x (.xzxz vecs))
                                    (* grad-y (.yyww vecs)))
                                 1.4142135)
                              blend-value))
           (blend (umbra.shaping:quintic-curve (.xy vecs)))
           (blend (vec4 blend (- 1 blend)))
           (out (dot grad-results (* (.zxzx blend) (.wwyy blend)))))
    (map-domain out -1 1 0 1)))

(defun-gpu value-perlin ((point :vec2)
                         (blend-value :float))
  (value-perlin point blend-value (lambda ((x :vec2)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu value-perlin ((point :vec3)
                         (blend-value :float)
                         (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4
                                                     :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (vec-1 (1- vec))
           (hash0 hash-x0 hash-y0 hash-z0 hash1 hash-x1 hash-y1 hash-z1 (funcall hash-fn cell))
           (grad-x0 (- hash-x0 0.5 +epsilon+))
           (grad-y0 (- hash-y0 0.5 +epsilon+))
           (grad-z0 (- hash-z0 0.5 +epsilon+))
           (grad-x1 (- hash-x1 0.5 +epsilon+))
           (grad-y1 (- hash-y1 0.5 +epsilon+))
           (grad-z1 (- hash-z1 0.5 +epsilon+))
           (temp1 (mix (1- (* hash0 2))
                       (* (inversesqrt (+ (* grad-x0 grad-x0)
                                          (* grad-y0 grad-y0)
                                          (* grad-z0 grad-z0)))
                          (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x0)
                             (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y0)
                             (* (.z vec) grad-z0))
                          1.1547005)
                       blend-value))
           (temp2 (mix (1- (* hash1 2))
                       (* (inversesqrt (+ (* grad-x1 grad-x1)
                                          (* grad-y1 grad-y1)
                                          (* grad-z1 grad-z1)))
                          (+ (* (.xyxy (vec2 (.x vec) (.x vec-1))) grad-x1)
                             (* (.xxyy (vec2 (.y vec) (.y vec-1))) grad-y1)
                             (* (.z vec-1) grad-z1))
                          1.1547005)
                       blend-value))
           (blend (umbra.shaping:quintic-curve vec))
           (out (mix temp1 temp2 (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend))))
           (out (dot out (* (.zxzx blend) (.wwyy blend)))))
    (map-domain out -1 1 0 1)))

(defun-gpu value-perlin ((point :vec3)
                         (blend-value :float))
  (value-perlin point blend-value (lambda ((x :vec3)) (umbra.hashing:fast32/4-per-corner x))))
