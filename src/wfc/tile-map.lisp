(in-package #:%syntex.wfc.tile-map)

(defstruct (tile-map
            (:constructor %make-tile-map)
            (:conc-name nil)
            (:predicate nil)
            (:copier nil))
  (grid nil :type grid:grid)
  (uncollapsed-count 0 :type u:non-negative-fixnum)
  (entropy-queue (pq:make-queue) :type pq:queue)
  (pattern-removal-stack nil :type list))

(defstruct (tile
            (:include grid:cell)
            (:constructor %make-tile (x y))
            (:conc-name "")
            (:predicate nil)
            (:copier nil))
  (possible-patterns (u:make-bit-vector 0) :type simple-bit-vector)
  (total-weight 0 :type u:non-negative-fixnum)
  (total-weight-log-weight 0.0 :type u:f32)
  (entropy-noise 0.0 :type u:f32)
  (collapsed-p nil :type boolean)
  (enabler-counts (make-array (list 0 4)) :type simple-array))

(defun make-tile-map (&key width height)
  (let* ((tiles (make-array (* width height)))
         (grid (grid:make-grid width height tiles))
         (tile-map (%make-tile-map :grid grid :uncollapsed-count (* width height))))
    (dotimes (y height)
      (dotimes (x width)
        (setf (aref tiles (+ (* y width) x)) (%make-tile x y))))
    tile-map))

(defun calculate-initial-weights (core pattern-count)
  (let* ((frequencies (core:frequencies core))
         (total-weight 0)
         (total-weight-log-weight 0.0))
    (dotimes (pattern-id pattern-count)
      (let ((frequency (aref frequencies pattern-id)))
        (incf total-weight frequency)
        (incf total-weight-log-weight (* frequency (log frequency 2)))))
    (values total-weight
            total-weight-log-weight)))

(defun make-tile-enabler-counts (core)
  (let* ((adjacencies (core:adjacencies core))
         (pattern-count (pat:get-count (core:patterns core)))
         (enabler-counts (make-array (list pattern-count 4))))
    (dotimes (pattern-id pattern-count)
      (loop :for direction :in '(:left :right :up :down)
            :for i :from 0
            :for count = (length (u:href (aref adjacencies pattern-id) direction))
            :do (setf (aref enabler-counts pattern-id i) count)))
    enabler-counts))

(defun prepare (core)
  (u:mvlet* ((rng (core:rng core))
             (grid (grid (core:tile-map core)))
             (pattern-count (pat:get-count (core:patterns core)))
             (total-weight total-weight-log-weight (calculate-initial-weights core pattern-count)))
    (grid:do-cells (grid tile)
      (setf (possible-patterns tile) (u:make-bit-vector pattern-count 1)
            (total-weight tile) total-weight
            (total-weight-log-weight tile) total-weight-log-weight
            (entropy-noise tile) (rng:float rng 0.0 0.0001)
            (enabler-counts tile) (make-tile-enabler-counts core)))))

(defun compute-entropy (tile)
  (let ((total-weight (total-weight tile))
        (total-weight-log-weight (total-weight-log-weight tile)))
    (+ (- (log total-weight 2)
          (/ total-weight-log-weight total-weight))
       (entropy-noise tile))))

(defun possible-pattern-p (tile pattern-id)
  (plusp (sbit (possible-patterns tile) pattern-id)))

(defun remove-possible-pattern (core tile pattern-id)
  (let ((frequency (aref (core:frequencies core) pattern-id))
        (possible-patterns (possible-patterns tile)))
    (setf (sbit possible-patterns pattern-id) 0)
    (when (every #'zerop possible-patterns)
      (error 'core:contradiction))
    (decf (total-weight tile) frequency)
    (decf (total-weight-log-weight tile) (* frequency (log frequency 2)))))

(defun choose-tile (core)
  (let* ((tile-map (core:tile-map core))
         (entropy-queue (entropy-queue tile-map)))
    (u:while (pq:peek entropy-queue)
      (let ((tile (pq:dequeue entropy-queue)))
        (unless (collapsed-p tile)
          (return-from choose-tile tile))))
    (error "Bug: Entropy heap is empty but there are still uncollapsed tiles.")))

(defun choose-pattern-id (core tile)
  (let* ((frequencies (core:frequencies core))
         (possible-patterns (possible-patterns tile))
         (remaining (rng:int (core:rng core) 0 (total-weight tile) nil)))
    (dotimes (pattern-id (length possible-patterns))
      (when (possible-pattern-p tile pattern-id)
        (let ((weight (aref frequencies pattern-id)))
          (if (>= remaining weight)
              (decf remaining weight)
              (return-from choose-pattern-id pattern-id)))))
    (error "Bug: Inconsistency detected with tile frequencies.")))

(defun collapse-tile (core tile)
  (let* ((tile-map (core:tile-map core))
         (patterns (core:patterns core))
         (possible-patterns (possible-patterns tile))
         (chosen-pattern-id (choose-pattern-id core tile)))
    (setf (collapsed-p tile) t
          (grid:value tile) (pat:get-origin-color patterns chosen-pattern-id))
    (dotimes (pattern-id (length possible-patterns))
      (when (and (possible-pattern-p tile pattern-id)
                 (/= pattern-id chosen-pattern-id))
        (setf (sbit possible-patterns pattern-id) 0)
        (push (cons tile pattern-id) (pattern-removal-stack tile-map))))))

(defun get-neighbor (tile-map tile direction &key periodic-p)
  (u:mvlet ((grid (grid tile-map))
            (x (grid:x tile))
            (y (grid:y tile))
            (ox oy (core:direction->offset direction)))
    (grid:get-cell grid (+ x ox) (+ y oy) :periodic-p periodic-p)))

(defun enabler-count (tile pattern-id direction)
  (let ((direction-index (core:direction->index direction)))
    (aref (enabler-counts tile) pattern-id direction-index)))

(defun (setf enabler-count) (value tile pattern-id direction)
  (let ((direction-index (core:direction->index direction)))
    (setf (aref (enabler-counts tile) pattern-id direction-index) value)))

(defun positive-enabler-counts-p (tile pattern-id)
  (and (plusp (enabler-count tile pattern-id :left))
       (plusp (enabler-count tile pattern-id :right))
       (plusp (enabler-count tile pattern-id :up))
       (plusp (enabler-count tile pattern-id :down))))
