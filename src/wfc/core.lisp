(in-package #:cl-user)

(defpackage #:%syntex.wfc.core
  (:local-nicknames
   (#:adj #:%syntex.wfc.adjacency)
   (#:grid #:%syntex.wfc.grid)
   (#:pat #:%syntex.wfc.pattern)
   (#:pq #:damn-fast-priority-queue)
   (#:rng #:seedable-rng)
   (#:sample #:%syntex.wfc.sample)
   (#:tm #:%syntex.wfc.tile-map)
   (#:u #:golden-utils))
  (:use #:cl)
  (:export
   #:wfc))

(in-package #:%syntex.wfc.core)

(defstruct (core
            (:conc-name nil)
            (:predicate nil)
            (:copier nil))
  (rng nil :type rng:generator)
  (seed "" :type string)
  (sample nil :type grid:grid)
  (patterns (pat:make-pattern-collection) :type pat:pattern-collection)
  (frequencies (make-array 0 :fill-pointer 0 :adjustable t) :type vector)
  (adjacencies (u:dict #'eql) :type hash-table)
  (origin-colors (u:make-ub32-array 0) :type u:ub32a)
  (uncollapsed-count 0 :type u:non-negative-fixnum)
  (tile-map nil :type grid:grid)
  (entropy-heap (pq:make-queue) :type pq:queue)
  (tile-removals (make-array 0 :fill-pointer 0 :adjustable t) :type vector))

(u:define-printer (core stream :type nil)
  (format stream "CORE"))

(defun generate-patterns (core &key size periodic-p)
  (pat:extract (patterns core)
               (frequencies core)
               (sample core)
               :size size
               :periodic-p periodic-p))

(defun generate-origin-colors (core)
  (let* ((patterns (patterns core))
         (pattern-count (pat:get-count patterns))
         (origin-colors (u:make-ub32-array pattern-count)))
    (dotimes (id pattern-count)
      (let* ((pattern (pat:get-pattern patterns id))
             (color (pat:get-origin-color pattern)))
        (setf (aref origin-colors id) color)))
    (setf (origin-colors core) origin-colors)))

(defun generate-adjacencies (core &key pattern-size)
  (let* ((patterns (patterns core))
         (adjacencies (adjacencies core)))
    (adj:generate adjacencies patterns pattern-size)))

(defun initialize-tile-map (core &key width height)
  (let ((adjacencies (adjacencies core))
        (frequencies (frequencies core))
        (pattern-count (pat:get-count (patterns core))))
    (tm:initialize (tile-map core) (rng core) pattern-count adjacencies frequencies)
    (setf (uncollapsed-count core) (* width height))))

(defun direction->offset (direction)
  (ecase direction
    (:left (values -1 0))
    (:right (values 1 0))
    (:up (values 0 -1))
    (:down (values 0 1))))

(defun propagate (core)
  (let ((adjacencies (adjacencies core))
        (frequencies (frequencies core))
        (tile-map (tile-map core))
        (tile-removals (tile-removals core))
        (entropy-heap (entropy-heap core)))
    (u:while (plusp (length tile-removals))
      (let ((removal-update (vector-pop tile-removals)))
        (destructuring-bind (tile-index x y) removal-update
          (dolist (direction '(:left :right :up :down))
            (u:mvlet* ((ox oy (direction->offset direction))
                       (neighbor (grid:get-cell tile-map (+ x ox) (+ y oy) :periodic-p t))
                       (neighbor-tile (grid:value neighbor)))
              (dolist (compatible (u:href adjacencies tile-index direction))
                (let ((enabler-counts (aref (tm::enabler-counts neighbor-tile) compatible)))
                  (when (= (u:href enabler-counts direction) 1)
                    (let ((contains-zero nil))
                      (u:do-hash-values (v enabler-counts)
                        (when (zerop v)
                          (setf contains-zero t)))
                      (unless contains-zero
                        (tm::remove-tile neighbor-tile compatible frequencies)
                        (when (zerop (hash-table-count (tm::possible neighbor-tile)))
                          (error "Contradiction"))
                        (pq:enqueue entropy-heap neighbor (tm::compute-entropy neighbor-tile))
                        (vector-push-extend (list compatible (grid:x neighbor) (grid:y neighbor)) tile-removals))))
                  (decf (u:href enabler-counts direction)))))))))))

(defun run (core)
  (let ((rng (rng core))
        (frequencies (frequencies core))
        (tile-map (tile-map core))
        (tile-removals (tile-removals core))
        (entropy-heap (entropy-heap core)))
    ;; the original code never inserts a tile in the queue before running the algorithm, so just
    ;; choosing 0,0 for now
    (let* ((n (grid:get-cell tile-map 0 0))
           (nv (grid:value n))
           (e (tm::compute-entropy nv)))
      (pq:enqueue entropy-heap n e))
    (u:while (plusp (uncollapsed-count core))
      (let* ((next (tm::choose-tile entropy-heap))
             (x (grid:x next))
             (y (grid:y next)))
        (print (list x y))
        (tm::collapse-tile rng tile-map tile-removals frequencies x y)
        (propagate core)
        (decf (uncollapsed-count core))))))

(defun wfc (sample-path
            &key
              (pattern-size 2)
              (periodic-p t)
              (output-width 10)
              (output-height 10)
              seed)
  (let* ((sample (sample:load sample-path))
         (tile-map (grid:make-grid output-width output-height))
         (core (make-core :rng (rng:make-generator seed)
                          :sample sample
                          :tile-map tile-map)))
    (generate-patterns core :size pattern-size :periodic-p periodic-p)
    (generate-origin-colors core)
    (generate-adjacencies core :pattern-size pattern-size)
    (initialize-tile-map core :width output-width :height output-height)
    (run core)
    core))
