(in-package #:%syntex.wfc.adjacency)

(u:fn-> make-edge-kernel (pat:pattern core:direction) kernel:kernel)
(declaim (inline make-edge-kernel))
(defun make-edge-kernel (pattern edge)
  (declare (optimize speed))
  (let ((grid (pat:grid pattern))
        (size (pat:size pattern)))
    (ecase edge
      ((:left :right)
       (kernel:make-kernel :grid grid :width (1- size) :height size))
      ((:up :down)
       (kernel:make-kernel :grid grid :width size :height (1- size))))))

(u:fn-> align-edge (kernel:kernel &key (:edge core:direction)) kernel:kernel)
(declaim (inline align-edge))
(defun align-edge (kernel &key edge)
  (declare (optimize speed))
  (ecase edge
    ((:left :up)
     (kernel:align kernel 0 0))
    (:right
     (kernel:align kernel 1 0))
    (:down
     (kernel:align kernel 0 1))))

(u:fn-> invert-edge (core:direction) core:direction)
(declaim (inline invert-edge))
(defun invert-edge (edge)
  (declare (optimize speed))
  (ecase edge
    (:left :right)
    (:right :left)
    (:up :down)
    (:down :up)))

(u:fn-> compatible-p
        (pat:pattern pat:pattern &key (:data1 u:ub32a) (:data2 u:ub32a) (:edge core:direction))
        boolean)
(defun compatible-p (pattern1 pattern2 &key data1 data2 edge)
  (declare (optimize speed))
  (flet ((%map (pattern data edge)
           (let ((kernel (make-edge-kernel pattern edge))
                 (index 0))
             (declare (u:ub8 index))
             (align-edge kernel :edge edge)
             (kernel:map kernel
                         (lambda (x)
                           (setf (aref data index) (grid:value x))
                           (incf index))))))
    (declare (inline %map))
    (%map pattern1 data1 edge)
    (%map pattern2 data2 (invert-edge edge))
    (equalp data1 data2)))

(u:fn-> generate (core:core &key (:pattern-size u:ub8)) null)
(declaim (inline generate))
(defun generate (core &key pattern-size)
  (declare (optimize speed))
  (let* ((pattern-count (pat:get-count core))
         (adjacencies (make-array pattern-count))
         (data-size (- (expt pattern-size 2) pattern-size))
         (data1 (u:make-ub32-array data-size))
         (data2 (u:make-ub32-array data-size)))
    (dotimes (i pattern-count)
      (let ((pattern1 (pat:get-pattern core i)))
        (setf (aref adjacencies i) (u:dict #'eq))
        (dotimes (j pattern-count)
          (let ((pattern2 (pat:get-pattern core j)))
            (dolist (edge '(:left :right :up :down))
              (when (compatible-p pattern1 pattern2 :data1 data1 :data2 data2 :edge edge)
                (push j (u:href (aref adjacencies i) edge))))))))
    (setf (core:adjacencies core) adjacencies)
    nil))
