(in-package #:%syntex.wfc.solver)

(u:fn-> enqueue-initial-tile (core:core) null)
(defun enqueue-initial-tile (core)
  (declare (optimize speed))
  (let* ((tile-map (core:tile-map core))
         (grid (tm:grid tile-map))
         (width (grid:width grid))
         (height (grid:height grid))
         (entropy-queue (tm:entropy-queue tile-map))
         (tile (grid:get-cell grid (truncate width 2) (truncate height 2))))
    (pq:enqueue entropy-queue tile (tm:compute-entropy tile))
    nil))

(u:fn-> propagate (core:core &key (:periodic-p boolean)) boolean)
(defun propagate (core &key periodic-p)
  (declare (optimize speed))
  (let* ((adjacencies (core:adjacencies core))
         (tile-map (core:tile-map core))
         (entropy-queue (tm:entropy-queue tile-map)))
    (u:while (tm:pattern-removal-stack tile-map)
      (let ((removal (pop (tm:pattern-removal-stack tile-map))))
        (destructuring-bind (tile . removed-pattern-id) removal
          (let ((pattern-adjacencies (aref adjacencies removed-pattern-id)))
            (dolist (direction '(:left :right :up :down))
              (u:when-let ((opposite-direction (adj:invert-edge direction))
                           (neighbor (tm:get-neighbor tile-map tile direction :periodic-p periodic-p)))
                (dolist (pattern-id (u:href pattern-adjacencies direction))
                  (when (and (= (tm:enabler-count neighbor pattern-id opposite-direction) 1)
                             (tm:possible-pattern-p neighbor pattern-id)
                             (tm:positive-enabler-counts-p neighbor pattern-id))
                    (tm:remove-possible-pattern core neighbor pattern-id)
                    (pq:enqueue entropy-queue neighbor (tm:compute-entropy neighbor))
                    (push (cons neighbor pattern-id) (tm:pattern-removal-stack tile-map)))
                  (decf (tm:enabler-count neighbor pattern-id opposite-direction)))))))))))

(defun update-progress (tile-map tile-count progress)
  (let ((current (truncate (- tile-count (tm:uncollapsed-count tile-map))
                           (/ tile-count 100))))
    (if (/= current progress)
        (progn
          (cond
            ((zerop progress)
             (format t "0%"))
            ((= current 100)
             (format t "100%~%"))
            ((zerop (mod current 10))
             (format t "~d%" current))
            (t (format t ".")))
          (finish-output)
          current)
        progress)))

(u:fn-> solve (core:core &key (:periodic-p boolean) (:show-progress-p boolean)) null)
(defun solve (core &key periodic-p show-progress-p)
  (declare (optimize speed))
  (let* ((tile-map (core:tile-map core))
         (grid (tm:grid tile-map))
         (tile-count (* (grid:width grid) (grid:height grid)))
         (progress 0))
    (enqueue-initial-tile core)
    (u:while (plusp (tm:uncollapsed-count tile-map))
      (let ((tile (tm:choose-tile core)))
        (tm:collapse-tile core tile)
        (propagate core :periodic-p periodic-p)
        (decf (tm:uncollapsed-count tile-map))
        (when show-progress-p
          (setf progress (update-progress tile-map tile-count progress)))))))
