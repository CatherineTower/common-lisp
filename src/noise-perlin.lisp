(in-package :umbra.noise)

;;;; Noise functions
;;;; Perlin noise

(defun-gpu perlin ((p :vec2)
                   (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (let* ((grad-x (- x 0.49999))
             (grad-y (- y 0.49999))
             (grad-results (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                              (+ (* grad-x (.xzxz pf-pfmin1))
                                 (* grad-y (.yyww pf-pfmin1)))))
             (blend (umbra.shaping:quintic-curve (.xy pf-pfmin1)))
             (blend2 (vec4 blend (- 1 blend))))
        (multf grad-results (vec4 "1.4142135623730950488016887242097"))
        (map-domain
         (dot grad-results (* (.zxzx blend2) (.wwyy blend2)))
         -1 1 0 1)))))

(defun-gpu perlin ((p :vec2))
  (perlin p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu perlin/surflet ((p :vec2)
                           (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (let* ((grad-x (- x 0.49999))
             (grad-y (- y 0.49999))
             (grad-results (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                              (+ (* grad-x (.xzxz pf-pfmin1))
                                 (* grad-y (.yyww pf-pfmin1)))))
             (vecs-len-sq (* pf-pfmin1 pf-pfmin1)))
        (setf vecs-len-sq (+ (.xzxz vecs-len-sq) (.yyww vecs-len-sq)))
        (multf grad-results (vec4 "2.3703703703703703703703703703704"))
        (map-domain
         (dot (umbra.shaping:falloff-squared-c2 (min (vec4 1) vecs-len-sq)) grad-results)
         -1 1 0 1)))))

(defun-gpu perlin-noise/surflet ((p :vec2))
  (perlin/surflet p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu perlin/improved ((p :vec2)
                            (hash-fn (function (:vec2) :vec4)))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi))))
         (hash (- (funcall hash-fn pi) 0.5))
         (grad-results (+ (* (.xzxz pf-pfmin1) (sign hash))
                          (* (.yyww pf-pfmin1) (sign (- (abs hash) 0.25)))))
         (blend (umbra.shaping:quintic-curve (.xy pf-pfmin1)))
         (blend2 (vec4 blend (- 1 blend))))
    (map-domain
     (dot grad-results (* (.zxzx blend2) (.wwyy blend2)))
     -1 1 0 1)))

(defun-gpu perlin/improved ((p :vec2))
  (perlin/improved p (lambda ((x :vec2)) (umbra.hashing:fast32 x))))

(defun-gpu perlin ((p :vec3)
                   (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (x0 y0 z0 x1 y1 z1) (funcall hash-fn pi)
      (let* ((grad-x0 (- x0 0.49999))
             (grad-y0 (- y0 0.49999))
             (grad-z0 (- z0 0.49999))
             (grad-x1 (- x1 0.49999))
             (grad-y1 (- y1 0.49999))
             (grad-z1 (- z1 0.49999))
             (grad-results0 (* (inversesqrt (+ (* grad-x0 grad-x0)
                                               (* grad-y0 grad-y0)
                                               (* grad-z0 grad-z0)))
                               (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x0)
                                  (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y0)
                                  (* (.z pf) (.z grad-z0)))))
             (grad-results1 (* (inversesqrt (+ (* grad-x1 grad-x1)
                                               (* grad-y1 grad-y1)
                                               (* grad-z1 grad-z1)))
                               (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x1)
                                  (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y1)
                                  (* (.z pf-min1) grad-z1))))
             (blend (umbra.shaping:quintic-curve pf))
             (res0 (mix grad-results0 grad-results1 (.z blend)))
             (blend2 (vec4 (.xy blend) (- 1 (.xy blend)))))
        (map-domain
         (* (dot res0 (* (.zxzx blend2) (.wwyy blend2)))
            "1.1547005383792515290182975610039")
         -1 1 0 1)))))

(defun-gpu perlin ((p :vec3))
  (perlin p (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu perlin/surflet ((p :vec3)
                           (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (x0 y0 z0 x1 y1 z1) (funcall hash-fn pi)
      (let* ((grad-x0 (- x0 0.49999))
             (grad-y0 (- y0 0.49999))
             (grad-z0 (- z0 0.49999))
             (grad-x1 (- x1 0.49999))
             (grad-y1 (- y1 0.49999))
             (grad-z1 (- z1 0.49999))
             (grad-results0 (* (inversesqrt (+ (* grad-x0 grad-x0)
                                               (* grad-y0 grad-y0)
                                               (* grad-z0 grad-z0)))
                               (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x0)
                                  (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y0)
                                  (* (.z pf) (.z grad-z0)))))
             (grad-results1 (* (inversesqrt (+ (* grad-x1 grad-x1)
                                               (* grad-y1 grad-y1)
                                               (* grad-z1 grad-z1)))
                               (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x1)
                                  (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y1)
                                  (* (.z pf-min1) grad-z1)))))
        (multf pf pf)
        (multf pf-min1 pf-min1)
        (let ((vecs-len-sq (+ (vec4 (.x pf) (.x pf-min1) (.x pf) (.x pf-min1))
                              (vec4 (.yy pf) (.yy pf-min1)))))
          (map-domain
           (* (+ (dot (umbra.shaping:falloff-squared-c2 (min (vec4 1) (+ vecs-len-sq (.z pf))))
                      grad-results0)
                 (dot (umbra.shaping:falloff-squared-c2 (min (vec4 1) (+ vecs-len-sq (.z pf-min1))))
                      grad-results1))
              "2.3703703703703703703703703703704")
           -1 1 0 1))))))

(defun-gpu perlin/surflet ((p :vec3))
  (perlin/surflet p (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu perlin/improved ((p :vec3)
                            (hash-fn (function (:vec3) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf))
         ((grad-results-00 :vec4))
         ((grad-results-01 :vec4))
         ((grad-results-02 :vec4))
         ((grad-results-0 :vec4))
         ((grad-results-10 :vec4))
         ((grad-results-11 :vec4))
         ((grad-results-12 :vec4))
         ((grad-results-1 :vec4)))
    (multiple-value-bind (low high) (funcall hash-fn pi)
      (decf low (vec4 0.5))
      (setf grad-results-00 (* (.xyxy (vec2 (.x pf) (.x pf-min1))) (sign low))
            low (- (abs low) 0.25)
            grad-results-01 (* (.xxyy (vec2 (.y pf) (.y pf-min1))) (sign low))
            grad-results-02 (* (.z pf) (sign (- (abs low) 0.125)))
            grad-results-0 (+ grad-results-00 grad-results-01 grad-results-02))
      (decf high (vec4 0.5))
      (setf grad-results-10 (* (.xyxy (vec2 (.x pf) (.x pf-min1))) (sign high))
            high (- (abs high) 0.25)
            grad-results-11 (* (.xxyy (vec2 (.y pf) (.y pf-min1))) (sign high))
            grad-results-12 (* (.z pf-min1) (sign (- (abs high) 0.125)))
            grad-results-1 (+ grad-results-10 grad-results-11 grad-results-12))
      (let* ((blend (umbra.shaping:quintic-curve pf))
             (res0 (mix grad-results-0 grad-results-1 (.z blend)))
             (blend2 (vec4 (.xy blend) (- 1 (.xy blend)))))
        (map-domain
         (* (dot res0 (* (.zxzx blend2) (.wwyy blend2))) (/ 2 3.0))
         -1 1 0 1)))))

(defun-gpu perlin/improved ((p :vec3))
  (perlin/improved p (lambda ((x :vec3)) (umbra.hashing:fast32 x))))

(defun-gpu perlin ((p :vec4)
                   (hash-fn (function (:vec4) (:vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (z0w0-0 z0w0-1 z0w0-2 z0w0-3
                          z1w0-0 z1w0-1 z1w0-2 z1w0-3
                          z0w1-0 z0w1-1 z0w1-2 z0w1-3
                          z1w1-0 z1w1-1 z1w1-2 z1w1-3)
        (funcall hash-fn pi)
      (decf z0w0-0 (vec4 0.49999))
      (decf z0w0-1 (vec4 0.49999))
      (decf z0w0-2 (vec4 0.49999))
      (decf z0w0-3 (vec4 0.49999))
      (decf z1w0-0 (vec4 0.49999))
      (decf z1w0-1 (vec4 0.49999))
      (decf z1w0-2 (vec4 0.49999))
      (decf z1w0-3 (vec4 0.49999))
      (decf z0w1-0 (vec4 0.49999))
      (decf z0w1-1 (vec4 0.49999))
      (decf z0w1-2 (vec4 0.49999))
      (decf z0w1-3 (vec4 0.49999))
      (decf z1w1-0 (vec4 0.49999))
      (decf z1w1-1 (vec4 0.49999))
      (decf z1w1-2 (vec4 0.49999))
      (decf z1w1-3 (vec4 0.49999))
      (let* ((grad-results-z0w0 (+ (* z0w0-0 z0w0-0) (* z0w0-1 z0w0-1)
                                   (* z0w0-2 z0w0-2) (* z0w0-3 z0w0-3)))
             (grad-results-z1w0 (+ (* z1w0-0 z1w0-0) (* z1w0-1 z1w0-1)
                                   (* z1w0-2 z1w0-2) (* z1w0-3 z1w0-3)))
             (grad-results-z0w1 (+ (* z0w1-0 z0w1-0) (* z0w1-1 z0w1-1)
                                   (* z0w1-2 z0w1-2) (* z0w1-3 z0w1-3)))
             (grad-results-z1w1 (+ (* z1w1-0 z1w1-0) (* z1w1-1 z1w1-1)
                                   (* z1w1-2 z1w1-2) (* z1w1-3 z1w1-3))))
        (multf grad-results-z0w0 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z0w0-0)
                                    (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z0w0-1)
                                    (* (.z pf) z0w0-2)
                                    (* (.w pf) z0w0-3)))
        (multf grad-results-z1w0 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z1w0-0)
                                    (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z1w0-1)
                                    (* (.z pf-min1) z1w0-2)
                                    (* (.w pf) z1w0-3)))
        (multf grad-results-z0w1 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z0w1-0)
                                    (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z0w1-1)
                                    (* (.z pf) z0w1-2)
                                    (* (.w pf-min1) z0w1-3)))
        (multf grad-results-z1w1 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z1w1-0)
                                    (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z1w1-1)
                                    (* (.z pf-min1) z1w1-2)
                                    (* (.w pf-min1) z1w1-3)))
        (let* ((blend (umbra.shaping:quintic-curve pf))
               (res0 (+ grad-results-z0w0 (* (- grad-results-z0w1 grad-results-z0w0) (.w blend))))
               (res1 (+ grad-results-z1w0 (* (- grad-results-z1w1 grad-results-z1w0) (.w blend)))))
          (incf res0 (* (- res1 res0) (.z blend)))
          (setf (.zw blend) (- 1 (.xy blend)))
          (map-domain
           (dot res0 (* (.zxzx blend) (.wwyy blend)))
           -1 1 0 1))))))

(defun-gpu perlin ((p :vec4))
  (perlin-noise p (lambda ((x :vec4)) (umbra.hashing:fast32-2/4-per-corner x))))
