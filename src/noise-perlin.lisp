(in-package :umbra.noise)

;;;; Noise functions
;;;; Perlin noise

(defconstant +perlin/scale+ (/ (sqrt 0.75)))
(defconstant +perlin/surflet-scale+ (/ (expt 0.75 3)))

(defun-gpu perlin ((p :vec2)
                   (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (let* ((x (- x 0.49999))
             (y (- y 0.49999))
             (results (* (inversesqrt (+ (* x x) (* y y)))
                         (+ (* x (.xzxz pf-pfmin1))
                            (* y (.yyww pf-pfmin1)))))
             (blend (umbra.shaping:quintic-curve (.xy pf-pfmin1)))
             (blend2 (vec4 blend (- 1 blend))))
        (multf results (vec4 1.4142135))
        (map-domain (dot results (* (.zxzx blend2) (.wwyy blend2))) -1 1 0 1)))))

(defun-gpu perlin ((p :vec2))
  (perlin p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu perlin/deriv ((p :vec2)
                         (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (let* ((x (- x 0.49999))
             (y (- y 0.49999))
             (norm (inversesqrt (+ (* x x) (* y y)))))
        (multf x norm)
        (multf y norm)
        (let* ((dotval (+ (* x (.xzxz pf-pfmin1)) (* y (.yyww pf-pfmin1))))
               (dotval0-grad0 (vec3 (.x dotval) (.x x) (.x y)))
               (dotval1-grad1 (vec3 (.y dotval) (.y x) (.y y)))
               (dotval2-grad2 (vec3 (.z dotval) (.z x) (.z y)))
               (dotval3-grad3 (vec3 (.w dotval) (.w x) (.w y)))
               (k0-gk0 (- dotval1-grad1 dotval0-grad0))
               (k1-gk1 (- dotval2-grad2 dotval0-grad0))
               (k2-gk2 (- dotval3-grad3 dotval2-grad2 k0-gk0))
               (blend (umbra.shaping:quintic-curve/interpolate-derivative (.xy pf-pfmin1)))
               (results (+ dotval0-grad0
                           (* (.x blend) k0-gk0)
                           (* (.y blend) (+ k1-gk1 (* (.x blend) k2-gk2))))))
          (incf (.yz results) (+ (* (.zw blend) (vec2 (.x k0-gk0) (.x k1-gk1)))
                                 (* (.yx blend) (.xx k2-gk2))))
          (map-domain (* results 1.4142135) (vec3 -1) (vec3 1) (vec3 0) (vec3 1)))))))

(defun-gpu perlin/deriv ((p :vec2))
  (perlin/deriv p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu perlin/surflet ((p :vec2)
                           (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (let* ((x (- x 0.49999))
             (y (- y 0.49999))
             (results (* (inversesqrt (+ (* x x) (* y y)))
                         (+ (* x (.xzxz pf-pfmin1))
                            (* y (.yyww pf-pfmin1)))))
             (vecs-len-sq (* pf-pfmin1 pf-pfmin1)))
        (setf vecs-len-sq (+ (.xzxz vecs-len-sq) (.yyww vecs-len-sq)))
        (multf results (vec4 2.3703704))
        (map-domain
         (dot (umbra.shaping:falloff-squared-c2 (min (vec4 1) vecs-len-sq)) results)
         -1 1 0 1)))))

(defun-gpu perlin/surflet ((p :vec2))
  (perlin/surflet p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu perlin/improved ((p :vec2)
                            (hash-fn (function (:vec2) :vec4)))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi))))
         (hash (- (funcall hash-fn pi) 0.5))
         (results (+ (* (.xzxz pf-pfmin1) (sign hash))
                     (* (.yyww pf-pfmin1) (sign (- (abs hash) 0.25)))))
         (blend (umbra.shaping:quintic-curve (.xy pf-pfmin1)))
         (blend2 (vec4 blend (- 1 blend))))
    (map-domain (dot results (* (.zxzx blend2) (.wwyy blend2))) -1 1 0 1)))

(defun-gpu perlin/improved ((p :vec2))
  (perlin/improved p (lambda ((x :vec2)) (umbra.hashing:fast32 x))))

(defun-gpu perlin/simplex ((p :vec2)
                           (hash-fn (function (:vec2) (:vec4 :vec4))))
  (let* ((simplex-points (vec3 (- 1 +simplex-2d/unskew-factor+)
                               (- +simplex-2d/unskew-factor+)
                               (- 1 (* 2 +simplex-2d/unskew-factor+))))
         (p (* p +simplex-2d/triangle-height+))
         (pi (floor (+ p (dot p (vec2 +simplex-2d/skew-factor+)))))
         (v0 (- pi (dot pi (vec2 +simplex-2d/unskew-factor+)) p)))
    (multiple-value-bind (x y) (funcall hash-fn pi)
      (let* ((v1pos-v1hash (if (< (.x v0) (.y v0))
                               (vec4 (.xy simplex-points) (.y x) (.y y))
                               (vec4 (.yx simplex-points) (.z x) (.z y))))
             (v12 (+ (vec4 (.xy v1pos-v1hash) (.zz simplex-points)) (.xyxy v0)))
             (x (- (vec3 (.x x) (.z v1pos-v1hash) (.w x)) 0.49999))
             (y (- (vec3 (.x y) (.w v1pos-v1hash) (.w y)) 0.49999))
             (results (* (inversesqrt (+ (* x x) (* y y)))
                         (+ (* x (vec3 (.x v0) (.xz v12)))
                            (* y (vec3 (.y v0) (.yw v12))))))
             (m (+ (* (vec3 (.x v0) (.xz v12)) (vec3 (.x v0) (.xz v12)))
                   (* (vec3 (.y v0) (.yw v12)) (vec3 (.y v0) (.yw v12))))))
        (setf m (max (- 0.5 m) 0.0))
        (multf m m)
        (map-domain (* (dot (* m m) results) +simplex-2d/norm-factor+) -1 1 0 1)))))

(defun-gpu perlin/simplex ((p :vec2))
  (perlin/simplex p (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu perlin ((p :vec3)
                   (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (x0 y0 z0 x1 y1 z1) (funcall hash-fn pi)
      (let* ((x0 (- x0 0.49999))
             (y0 (- y0 0.49999))
             (z0 (- z0 0.49999))
             (x1 (- x1 0.49999))
             (y1 (- y1 0.49999))
             (z1 (- z1 0.49999))
             (results0 (* (inversesqrt (+ (* x0 x0) (* y0 y0) (* z0 z0)))
                          (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) x0)
                             (* (.xxyy (vec2 (.y pf) (.y pf-min1))) y0)
                             (* (.z pf) (.z z0)))))
             (results1 (* (inversesqrt (+ (* x1 x1) (* y1 y1) (* z1 z1)))
                          (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) x1)
                             (* (.xxyy (vec2 (.y pf) (.y pf-min1))) y1)
                             (* (.z pf-min1) z1))))
             (blend (umbra.shaping:quintic-curve pf))
             (res0 (mix results0 results1 (.z blend)))
             (blend2 (vec4 (.xy blend) (- 1 (.xy blend)))))
        (map-domain (* (dot res0 (* (.zxzx blend2) (.wwyy blend2))) +perlin/scale+) -1 1 0 1)))))

(defun-gpu perlin ((p :vec3))
  (perlin p (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu perlin/surflet ((p :vec3)
                           (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (x0 y0 z0 x1 y1 z1) (funcall hash-fn pi)
      (let* ((x0 (- x0 0.49999))
             (y0 (- y0 0.49999))
             (z0 (- z0 0.49999))
             (x1 (- x1 0.49999))
             (y1 (- y1 0.49999))
             (z1 (- z1 0.49999))
             (results0 (* (inversesqrt (+ (* x0 x0) (* y0 y0) (* z0 z0)))
                          (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) x0)
                             (* (.xxyy (vec2 (.y pf) (.y pf-min1))) y0)
                             (* (.z pf) (.z z0)))))
             (results1 (* (inversesqrt (+ (* x1 x1) (* y1 y1) (* z1 z1)))
                          (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) x1)
                             (* (.xxyy (vec2 (.y pf) (.y pf-min1))) y1)
                             (* (.z pf-min1) z1)))))
        (multf pf pf)
        (multf pf-min1 pf-min1)
        (let ((vecs-len-sq (+ (vec4 (.x pf) (.x pf-min1) (.x pf) (.x pf-min1))
                              (vec4 (.yy pf) (.yy pf-min1)))))
          (map-domain
           (* (+ (dot (umbra.shaping:falloff-squared-c2 (min (vec4 1) (+ vecs-len-sq (.z pf))))
                      results0)
                 (dot (umbra.shaping:falloff-squared-c2 (min (vec4 1) (+ vecs-len-sq (.z pf-min1))))
                      results1))
              +perlin/surflet-scale+)
           -1 1 0 1))))))

(defun-gpu perlin/surflet ((p :vec3))
  (perlin/surflet p (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu perlin/improved ((p :vec3)
                            (hash-fn (function (:vec3) (:vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf))
         ((results-00 :vec4))
         ((results-01 :vec4))
         ((results-02 :vec4))
         ((results-0 :vec4))
         ((results-10 :vec4))
         ((results-11 :vec4))
         ((results-12 :vec4))
         ((results-1 :vec4)))
    (multiple-value-bind (low high) (funcall hash-fn pi)
      (decf low (vec4 0.5))
      (setf results-00 (* (.xyxy (vec2 (.x pf) (.x pf-min1))) (sign low))
            low (- (abs low) 0.25)
            results-01 (* (.xxyy (vec2 (.y pf) (.y pf-min1))) (sign low))
            results-02 (* (.z pf) (sign (- (abs low) 0.125)))
            results-0 (+ results-00 results-01 results-02))
      (decf high (vec4 0.5))
      (setf results-10 (* (.xyxy (vec2 (.x pf) (.x pf-min1))) (sign high))
            high (- (abs high) 0.25)
            results-11 (* (.xxyy (vec2 (.y pf) (.y pf-min1))) (sign high))
            results-12 (* (.z pf-min1) (sign (- (abs high) 0.125)))
            results-1 (+ results-10 results-11 results-12))
      (let* ((blend (umbra.shaping:quintic-curve pf))
             (res0 (mix results-0 results-1 (.z blend)))
             (blend2 (vec4 (.xy blend) (- 1 (.xy blend)))))
        (map-domain (* (dot res0 (* (.zxzx blend2) (.wwyy blend2))) (/ 2 3.0)) -1 1 0 1)))))

(defun-gpu perlin/improved ((p :vec3))
  (perlin/improved p (lambda ((x :vec3)) (umbra.hashing:fast32 x))))

(defun-gpu perlin/simplex ((p :vec3)
                           (hash-fn (function (:vec3 :vec3 :vec3) (:vec4 :vec4 :vec4))))
  (multiple-value-bind (pi pi1 pi2 v1234-x v1234-y v1234-z) (simplex/get-corner-vectors p)
    (multiple-value-bind (x y z) (funcall hash-fn pi pi1 pi2)
      (let* ((x (- x (vec4 0.49999)))
             (y (- y (vec4 0.49999)))
             (z (- z (vec4 0.49999)))
             (results (* (inversesqrt (+ (* x x) (* y y) (* z z)))
                         (+ (* x v1234-x) (* y v1234-y) (* z v1234-z))))
             (weights (simplex/get-surflet-weights v1234-x v1234-y v1234-z)))
        (map-domain (* (dot weights results) +simplex-3d/norm-factor+) -1 1 0 1)))))

(defun-gpu perlin/simplex ((p :vec3))
  (perlin/simplex p (lambda ((x :vec3) (y :vec3) (z :vec3))
                      (umbra.hashing:fast32/3-per-corner x y z))))

(defun-gpu perlin ((p :vec4)
                   (hash-fn (function (:vec4) (:vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (z0w0-0 z0w0-1 z0w0-2 z0w0-3
                          z1w0-0 z1w0-1 z1w0-2 z1w0-3
                          z0w1-0 z0w1-1 z0w1-2 z0w1-3
                          z1w1-0 z1w1-1 z1w1-2 z1w1-3)
        (funcall hash-fn pi)
      (let* ((z0w0-0 (- z0w0-0 (vec4 0.49999)))
             (z0w0-1 (- z0w0-1 (vec4 0.49999)))
             (z0w0-2 (- z0w0-2 (vec4 0.49999)))
             (z0w0-3 (- z0w0-3 (vec4 0.49999)))
             (z1w0-0 (- z1w0-0 (vec4 0.49999)))
             (z1w0-1 (- z1w0-1 (vec4 0.49999)))
             (z1w0-2 (- z1w0-2 (vec4 0.49999)))
             (z1w0-3 (- z1w0-3 (vec4 0.49999)))
             (z0w1-0 (- z0w1-0 (vec4 0.49999)))
             (z0w1-1 (- z0w1-1 (vec4 0.49999)))
             (z0w1-2 (- z0w1-2 (vec4 0.49999)))
             (z0w1-3 (- z0w1-3 (vec4 0.49999)))
             (z1w1-0 (- z1w1-0 (vec4 0.49999)))
             (z1w1-1 (- z1w1-1 (vec4 0.49999)))
             (z1w1-2 (- z1w1-2 (vec4 0.49999)))
             (z1w1-3 (- z1w1-3 (vec4 0.49999)))
             (results-z0w0 (+ (* z0w0-0 z0w0-0) (* z0w0-1 z0w0-1)
                              (* z0w0-2 z0w0-2) (* z0w0-3 z0w0-3)))
             (results-z1w0 (+ (* z1w0-0 z1w0-0) (* z1w0-1 z1w0-1)
                              (* z1w0-2 z1w0-2) (* z1w0-3 z1w0-3)))
             (results-z0w1 (+ (* z0w1-0 z0w1-0) (* z0w1-1 z0w1-1)
                              (* z0w1-2 z0w1-2) (* z0w1-3 z0w1-3)))
             (results-z1w1 (+ (* z1w1-0 z1w1-0) (* z1w1-1 z1w1-1)
                              (* z1w1-2 z1w1-2) (* z1w1-3 z1w1-3))))
        (multf results-z0w0 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z0w0-0)
                               (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z0w0-1)
                               (* (.z pf) z0w0-2)
                               (* (.w pf) z0w0-3)))
        (multf results-z1w0 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z1w0-0)
                               (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z1w0-1)
                               (* (.z pf-min1) z1w0-2)
                               (* (.w pf) z1w0-3)))
        (multf results-z0w1 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z0w1-0)
                               (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z0w1-1)
                               (* (.z pf) z0w1-2)
                               (* (.w pf-min1) z0w1-3)))
        (multf results-z1w1 (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) z1w1-0)
                               (* (.xxyy (vec2 (.y pf) (.y pf-min1))) z1w1-1)
                               (* (.z pf-min1) z1w1-2)
                               (* (.w pf-min1) z1w1-3)))
        (let* ((blend (umbra.shaping:quintic-curve pf))
               (res0 (+ results-z0w0 (* (- results-z0w1 results-z0w0) (.w blend))))
               (res1 (+ results-z1w0 (* (- results-z1w1 results-z1w0) (.w blend)))))
          (incf res0 (* (- res1 res0) (.z blend)))
          (setf (.zw blend) (- 1 (.xy blend)))
          (map-domain (dot res0 (* (.zxzx blend) (.wwyy blend))) -1 1 0 1))))))

(defun-gpu perlin ((p :vec4))
  (perlin p (lambda ((x :vec4)) (umbra.hashing:fast32-2/4-per-corner x))))
