(in-package :umbra.noise)

;;;; Noise functions
;;;; Hermite noise

(defun-gpu hermite ((point :vec2)
                    (hash-fn (function (:vec2) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x hash-y (funcall hash-fn cell))
           (hash-x (- hash-x 0.5 +epsilon+))
           (hash-y (- hash-y 0.5 +epsilon+))
           (norm (inversesqrt (+ (* hash-x hash-x) (* hash-y hash-y))))
           (hash-x (* hash-x norm))
           (hash-y (* hash-y norm))
           (out (umbra.shaping:quintic-hermite
                 (.y vec) (.xy hash-x) (.zw hash-x) (.xy hash-y) (.zw hash-y)))
           (out (* (umbra.shaping:quintic-hermite (.x vec) (.x out) (.y out) (.z out) (.w out))
                   2.2627418)))
    (map-domain out -1 1 0 1)))

(defun-gpu hermite ((point :vec2))
  (hermite point (lambda ((x :vec2)) (umbra.hashing:fast32/2-per-corner x))))

(defun-gpu hermite ((point :vec3)
                    (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point cell))
           (hash-x0 hash-y0 hash-z0 hash-x1 hash-y1 hash-z1 (funcall hash-fn cell))
           (hash-x0 (- hash-x0 0.5 +epsilon+))
           (hash-y0 (- hash-y0 0.5 +epsilon+))
           (hash-z0 (- hash-z0 0.5 +epsilon+))
           (hash-x1 (- hash-x1 0.5 +epsilon+))
           (hash-y1 (- hash-y1 0.5 +epsilon+))
           (hash-z1 (- hash-z1 0.5 +epsilon+))
           (norm0 (inversesqrt (+ (* hash-x0 hash-x0) (* hash-y0 hash-y0) (* hash-z0 hash-z0))))
           (norm1 (inversesqrt (+ (* hash-x1 hash-x1) (* hash-y1 hash-y1) (* hash-z1 hash-z1))))
           (hash-x0 (* hash-x0 norm0))
           (hash-y0 (* hash-y0 norm0))
           (hash-z0 (* hash-z0 norm0))
           (hash-x1 (* hash-x1 norm1))
           (hash-y1 (* hash-y1 norm1))
           (hash-z1 (* hash-z1 norm1))
           (ival igrad-x igrad-y (umbra.shaping:quintic-hermite
                                  (.z vec) hash-x0 hash-x1 hash-y0 hash-y1 hash-z0 hash-z1))
           (out (umbra.shaping:quintic-hermite
                 (.y vec)
                 (vec4 (.xy ival) (.xy igrad-x))
                 (vec4 (.zw ival) (.zw igrad-x))
                 (vec4 (.xy igrad-y) 0 0)
                 (vec4 (.zw igrad-y) 0 0)))
           (out (* (umbra.shaping:quintic-hermite (.x vec) (.x out) (.y out) (.z out) (.w out))
                   1.8475208)))
    (map-domain out -1 1 0 1)))

(defun-gpu hermite ((point :vec3))
  (hermite point (lambda ((x :vec3)) (umbra.hashing:fast32/3-per-corner x))))
