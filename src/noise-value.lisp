(in-package :umbra.noise)

;;;; Noise functions
;;;; Value noise

(defun-gpu value ((point :vec2)
                  (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point pi))
         (hash (funcall hash-fn cell))
         (blend (umbra.shaping:quintic-curve vec))
         (blend (vec4 blend (- 1 blend))))
    (dot hash (* (.zxzx blend) (.wwyy blend)))))

(defun-gpu value ((point :vec2))
  (value point (lambda ((x :vec2)) (umbra.hashing:fast32 x))))

(defun-gpu value/deriv ((point :vec2)
                        (hash-fn (function (:vec2) :vec4)))
  (let* ((cell (floor point))
         (vec (- point cell))
         (hash (funcall hash-fn cell))
         (blend (umbra.shaping:quintic-curve/interpolate-derivative vec))
         (out (mix (.xyxz hash) (.zwyw hash) (.yyxx blend))))
    (+ (vec3 (.x out) 0 0)
       (* (- (.yyw out) (.xxz out)) (.xzw blend)))))

(defun-gpu value/deriv ((point :vec2))
  (value/deriv point (lambda ((x :vec2)) (umbra.hashing:fast32 x))))

(defun-gpu value ((point :vec3)
                  (hash-fn (function (:vec3) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point pi))
           (low-z high-z (funcall hash-fn cell))
           (blend (umbra.shaping:quintic-curve vec))
           (out (mix low-z high-z (.z blend)))
           (blend (vec4 (.xy blend) (- 1 (.xy blend)))))
    (dot out (* (.zxzx blend) (.wwyy blend)))))

(defun-gpu value ((point :vec3))
  (value point (lambda ((x :vec3)) (umbra.hashing:fast32 x))))

(defun-gpu value/deriv ((point :vec3)
                        (hash-fn (function (:vec3) (:vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point pi))
           (low-z high-z (funcall hash-fn cell))
           (blend (umbra.shaping:quintic-curve vec))
           (temp1 (mix low-z high-z (.z blend)))
           (temp1 (mix (.xyxz temp1) (.zwyw temp1) (.yyxx blend)))
           (temp2 (mix (vec4 (.xy low-z) (.xy high-z))
                       (vec4 (.zw low-z) (.zw high-z))
                       (.y blend)))
           (temp2 (mix (.xz temp2) (.yw temp2) (.x blend))))
    (+ (vec4 (.x temp1) 0 0 0)
       (* (- (vec4 (.yyw temp1) (.y temp2)) (vec4 (.xxz temp1) (.x temp2)))
          (vec4 (.x blend) (umbra.shaping:quintic-curve/derivative vec))))))

(defun-gpu value/deriv ((point :vec3))
  (value/deriv point (lambda ((x :vec3)) (umbra.hashing:fast32 x))))

(defun-gpu value ((point :vec4)
                  (hash-fn (function (:vec4) (:vec4 :vec4 :vec4 :vec4))))
  (mvlet* ((cell (floor point))
           (vec (- point pi))
           (z0w0 z1w0 z0w1 z1w1 (funcall hash-fn cell))
           (blend (umbra.shaping:quintic-curve vec))
           (temp (+ z0w0 (* (- z0w1 z0w0) (.w blend))))
           (temp (+ temp (* (- (+ z1w0 (* (- z1w1 z1w0) (.w blend))) temp) (.z blend))))
           (blend (vec4 (.zw blend) (- 1 (.xy blend)))))
    (dot temp (* (.zxzx blend) (.wwyy blend)))))

(defun-gpu value ((point :vec4))
  (value point (lambda ((x :vec4)) (umbra.hashing:fast32-2 x))))
