(in-package :umbra.noise)

;;;; Noise functions
;;;; Cubist noise

(defun-gpu cubist ((p :vec2)
                   (range-clamp :vec2)
                   (hash-fn (function (:vec2) (:vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf-pfmin1 (- (.xyxy p) (vec4 pi (1+ pi)))))
    (multiple-value-bind (x y hash) (funcall hash-fn pi)
      (let* ((grad-x (- x 0.49999))
             (grad-y (- y 0.49999))
             (grad-results (* (- hash 0.5)
                              (/ (* (inversesqrt (+ (* grad-x grad-x) (* grad-y grad-y)))
                                    (+ (* grad-x (.xzxz pf-pfmin1))
                                       (* grad-y (.yyww pf-pfmin1)))))))
             (blend (umbra.shaping:quintic-curve (.xy pf-pfmin1)))
             (blend2 (vec4 blend (- 1 blend)))
             (final (dot grad-results (* (.zxzx blend2) (.wwyy blend2)))))
        (saturate (* (- final (.x range-clamp)) (.y range-clamp)))))))

(defun-gpu cubist ((p :vec2)
                   (range-clamp :vec2))
  (cubist p range-clamp (lambda ((x :vec2)) (umbra.hashing:fast32/3-per-corner x))))

(defun-gpu cubist ((p :vec3)
                   (range-clamp :vec2)
                   (hash-fn (function (:vec3) (:vec4 :vec4 :vec4 :vec4
                                               :vec4 :vec4 :vec4 :vec4))))
  (let* ((pi (floor p))
         (pf (- p pi))
         (pf-min1 (1- pf)))
    (multiple-value-bind (x0 y0 z0 hash0 x1 y1 z1 hash1) (funcall hash-fn pi)
      (let* ((grad-x0 (- x0 0.49999))
             (grad-y0 (- y0 0.49999))
             (grad-z0 (- z0 0.49999))
             (grad-x1 (- x1 0.49999))
             (grad-y1 (- y1 0.49999))
             (grad-z1 (- z1 0.49999))
             (grad-results0 (* (- hash0 0.5)
                               (/ (* (inversesqrt (+ (* grad-x0 grad-x0)
                                                     (* grad-y0 grad-y0)
                                                     (* grad-z0 grad-z0)))
                                     (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x0)
                                        (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y0)
                                        (* (.z pf) grad-z0))))))
             (grad-results1 (* (- hash1 0.5)
                               (/ (* (inversesqrt (+ (* grad-x1 grad-x1)
                                                     (* grad-y1 grad-y1)
                                                     (* grad-z1 grad-z1)))
                                     (+ (* (.xyxy (vec2 (.x pf) (.x pf-min1))) grad-x1)
                                        (* (.xxyy (vec2 (.y pf) (.y pf-min1))) grad-y1)
                                        (* (.z pf-min1) grad-z1))))))
             (blend (umbra.shaping:quintic-curve pf))
             (res0 (mix grad-results0 grad-results1 (.z blend)))
             (blend2 (vec4 (.xy blend) (- 1 (.xy blend))))
             (final (dot res0 (* (.zxzx blend2) (.wwyy blend2)))))
        (saturate (* (- final (.x range-clamp)) (.y range-clamp)))))))

(defun-gpu cubist ((p :vec3)
                   (range-clamp :vec2))
  (cubist p range-clamp (lambda ((x :vec3)) (umbra.hashing:fast32/4-per-corner x))))
