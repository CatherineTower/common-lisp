(in-package #:box.math.test)

(setf *default-test-function* #'equalp)

(plan 90)

(diag "accessors")
(let ((v (v2:make 1 2)))
  (is (v2:x v) 1)
  (is (v2:y v) 2)
  (psetf (v2:x v) 10.0
         (v2:y v) 20.0)
  (is (v2:x v) 10)
  (is (v2:y v) 20))

(diag "copy")
(let ((v (v2:make 1 2))
      (o (v2:zero)))
  (is (v2:copy! o v) v)
  (is o v)
  (is (v2:copy v) v)
  (isnt v (v2:copy v) :test #'eq))

(diag "clamp")
(let ((v (v2:make -1.5185602 0.3374052))
      (r (v2:make -1 0.3374052))
      (o (v2:zero)))
  (is (v2:clamp! o v :min -1.0 :max 1.0) r)
  (is o r)
  (is (v2:clamp v :min -1.0 :max 1.0) r)
  (is (v2:clamp v) v))

(diag "zero")
(let ((v (v2:make -0.72470546 0.57963276)))
  (is (v2:zero! v) v2:+zero+)
  (is v v2:+zero+)
  (is (v2:zero) v2:+zero+))

(diag "one")
(let ((v (v2:make -81 92))
      (r (v2:make 1 1)))
  (is (v2:one! v) r)
  (is v r)
  (is (v2:one) r))

(diag "list conversion")
(is (v2:to-list (v2:make 1 2)) '(1 2))
(is (v2:from-list '(1 2)) (v2:make 1 2))

(diag "equality")
(let ((v1 (v2:make 0.8598654 -0.4803753))
      (v2 (v2:make 1e-8 1e-8)))
  (ok (v2:= v1 v1))
  (ok (v2:~ (v2:+ v1 v2) v1))
  (ok (v2:~ v2 v2:+zero+)))

(diag "addition")
(let ((v1 (v2:make 0.4110496 -0.87680984))
      (v2 (v2:make 0.1166687 0.42538047))
      (r (v2:make 0.5277183 -0.45142937))
      (o (v2:zero)))
  (is (v2:+! o v1 v2) r)
  (is o r)
  (is (v2:+ v1 v2) r)
  (is (v2:+ v1 v2:+zero+) v1)
  (is (v2:+ v2:+zero+ v2) v2))

(diag "subtraction")
(let ((v1 (v2:make -0.16772795 -0.7287135))
      (v2 (v2:make -0.69658303 0.6168339))
      (r (v2:make 0.5288551 -1.3455474))
      (o (v2:zero)))
  (is (v2:-! o v1 v2) r)
  (is o r)
  (is (v2:- v1 v2) r)
  (is (v2:- v1 v2:+zero+) v1))

(diag "hadamard product")
(let ((v1 (v2:make -0.6219859 -0.80110574))
      (v2 (v2:make 0.6687746 -0.21906853))
      (r (v2:make -0.4159684 0.17549706))
      (o (v2:zero)))
  (is (v2:*! o v1 v2) r)
  (is o r)
  (is (v2:* v1 v2) r)
  (is (v2:* v1 v2:+zero+) v2:+zero+)
  (is (v2:* v2:+zero+ v2) v2:+zero+))

(diag "hadamard quotient")
(let ((v1 (v2:make 0.9498384 0.4066379))
      (v2 (v2:make 0.32331443 0.17439032))
      (r (v2:make 2.9378164 2.3317688))
      (o (v2:zero)))
  (is (v2:/! o v1 v2) r)
  (is o r)
  (is (v2:/ v1 v2) r)
  (is (v2:/ v1 v2:+zero+) v2:+zero+)
  (is (v2:/ v2:+zero+ v2) v2:+zero+))

(diag "scalar product")
(let ((v (v2:make 0.82007027 -0.53582144))
      (r (v2:make 0.7762602 -0.5071966))
      (o (v2:zero)))
  (is (v2:scale! o v 0.94657767) r)
  (is o r)
  (is (v2:scale v 0.94657767) r))

(diag "dot product")
(is (v2:dot (v2:make -0.21361923 0.39387107)
            (v2:make -0.13104868 0.399935))
    0.18551734)
(is (v2:dot (v2:make 1 0) (v2:make 0 1)) 0)
(is (v2:dot (v2:make 1 0) (v2:make 1 0)) 1)
(is (v2:dot (v2:make 1 0) (v2:make -1 0)) -1)

(diag "length")
(is (v2:length v2:+zero+) 0)
(is (v2:length (v2:make 1 0)) 1)
(is (v2:length (v2:make 0.32979298 0.2571392)) 0.4181913)

(diag "normalize")
(let ((v (v2:make -0.6589291 0.23270178))
      (r (v2:make -0.942928 0.3329964))
      (o (v2:zero)))
  (is (v2:normalize! o v) r)
  (is o r)
  (is (v2:normalize v) r)
  (is (v2:normalize (v2:make 2 0)) (v2:make 1 0))
  (is (v2:normalize (v2:make 0 2)) (v2:make 0 1))
  (is (v2:normalize (v2:make 0 0)) (v2:make 0 0)))

(diag "round")
(let ((v (v2:make -0.70498157 0.3615427))
      (r (v2:make -1 0))
      (o (v2:zero)))
  (is (v2:round! o v) r)
  (is o r)
  (is (v2:round v) r))

(diag "abs")
(let ((v (v2:make -0.4241562 -0.52400947))
      (r (v2:make 0.4241562 0.52400947))
      (o (v2:zero)))
  (is (v2:abs! o v) r)
  (is o r)
  (is (v2:abs v) r))

(diag "negate")
(let ((v (v2:make 0.7823446 0.95027566))
      (r (v2:make -0.7823446 -0.95027566))
      (o (v2:zero)))
  (is (v2:negate! o v) r)
  (is o r)
  (is (v2:negate v) r))

(diag "angle")
(let ((angle (v2:angle (v2:make 0 1) (v2:make 1 0))))
  (ok (<= (abs (- angle (/ pi 2))) 1e-7)))
(let ((angle (v2:angle (v2:make 1 0) (v2:make 1 1))))
  (ok (<= (abs (- angle (/ pi 4))) 1e-7)))

(diag "zero vector predicate")
(ok (v2:zero-p v2:+zero+))
(ok (v2:zero-p (v2:make 0 0)))

(diag "direction equality")
(ok (v2:direction= (v2:make 0.0073252916 0) (v2:make 0.31148136 0)))
(ok (v2:direction= (v2:make 0 0.6982585) (v2:make 0 0.72258794)))

(diag "linear interpolation")
(let ((v1 (v2:make 0.74485755 0.092342734))
      (v2 (v2:make 0.19426346 0.9881369))
      (r (v2:make 0.4695605 0.5402398))
      (o (v2:zero)))
  (is (v2:lerp! o v1 v2 0.5) r)
  (is o r)
  (is (v2:lerp v1 v2 0.5) r)
  (is (v2:lerp v1 v2 0.0) v1)
  (is (v2:lerp v1 v2 1.0) v2))

(diag "comparators")
(let ((v1 (v2:make 0.34003425 -0.4920528))
      (v2 (v2:make 0.6535034 -0.11586404))
      (v3 (v2:make 0.9715252 0.8300271))
      (v4 (v2:make 1 2))
      (v5 (v2:make 3 4)))
  (ok (v2:< v2 v3))
  (ok (v2:<= v4 v4))
  (ok (v2:<= v4 v5))
  (ok (v2:> v3 v1))
  (ok (v2:>= v4 v4))
  (ok (v2:>= v5 v4)))

(diag "component-wise minimum")
(let* ((v1 (v2:make 0.98117805 0.06889212))
       (v2 (v2:make 0.8774886 0.25179327))
       (r (v2:make (v2:x v2) (v2:y v1)))
       (o (v2:zero)))
  (is (v2:min! o v1 v2) r)
  (is o r)
  (is (v2:min v1 v2) r))

(diag "component-wise maximum")
(let* ((v1 (v2:make 0.64380646 0.38965714))
       (v2 (v2:make 0.6341989 0.5274999))
       (r (v2:make (v2:x v1) (v2:y v2)))
       (o (v2:zero)))
  (is (v2:max! o v1 v2) r)
  (is o r)
  (is (v2:max v1 v2) r))

(finalize)
