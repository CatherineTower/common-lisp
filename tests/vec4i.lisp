(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 78)

(diag "accessors")
(let ((v (v4i:make 1 2 3 4)))
  (is (v4i:x v) 1)
  (is (v4i:y v) 2)
  (is (v4i:z v) 3)
  (is (v4i:w v) 4)
  (psetf (v4i:x v) 10
         (v4i:y v) 20
         (v4i:z v) 30
         (v4i:w v) 40)
  (is (v4i:x v) 10)
  (is (v4i:y v) 20)
  (is (v4i:z v) 30)
  (is (v4i:w v) 40))

(diag "copy")
(let ((v (v4i:make 1 2 3 4))
      (o (v4i:zero)))
  (is (v4i:copy! o v) v)
  (is o v)
  (is (v4i:copy v) v)
  (isnt v (v4i:copy v) :test #'eq))

(diag "clamp")
(let ((v (v4i:make -15 33 152 181))
      (r (v4i:make -1 1 1 1))
      (o (v4i:zero)))
  (is (v4i:clamp! o v :min -1 :max 1) r)
  (is o r)
  (is (v4i:clamp v :min -1 :max 1) r)
  (is (v4i:clamp v) v))

(diag "zero")
(let ((v (v4i:make -72 57 87 44)))
  (is (v4i:zero! v) v4i:+zero+)
  (is v v4i:+zero+)
  (is (v4i:zero) v4i:+zero+))

(diag "list conversion")
(is (v4i:to-list (v4i:make 1 2 3 4)) '(1 2 3 4))
(is (v4i:from-list '(1 2 3 4)) (v4i:make 1 2 3 4))

(diag "equality")
(let ((v1 (v4i:make 85 -48 -38 26)))
  (ok (v4i:= v1 v1)))

(diag "addition")
(let ((v1 (v4i:make 41 -87 -62 61))
      (v2 (v4i:make 11 42 73 19))
      (r (v4i:make 52 -45 11 80))
      (o (v4i:zero)))
  (is (v4i:+! o v1 v2) r)
  (is o r)
  (is (v4i:+ v1 v2) r)
  (is (v4i:+ v1 v4i:+zero+) v1)
  (is (v4i:+ v4i:+zero+ v2) v2))

(diag "subtraction")
(let ((v1 (v4i:make -16 -72 -89 55))
      (v2 (v4i:make -69 61 -78 9))
      (r (v4i:make 53 -133 -11 46))
      (o (v4i:zero)))
  (is (v4i:-! o v1 v2) r)
  (is o r)
  (is (v4i:- v1 v2) r)
  (is (v4i:- v1 v4i:+zero+) v1))

(diag "hadamard product")
(let ((v1 (v4i:make -62 -80 -6 37))
      (v2 (v4i:make 66 -21 14 9))
      (r (v4i:make -4092 1680 -84 333))
      (o (v4i:zero)))
  (is (v4i:*! o v1 v2) r)
  (is o r)
  (is (v4i:* v1 v2) r)
  (is (v4i:* v1 v4i:+zero+) v4i:+zero+)
  (is (v4i:* v4i:+zero+ v2) v4i:+zero+))

(diag "hadamard quotient")
(let ((v1 (v4i:make 94 40 -72 98))
      (v2 (v4i:make 32 17 -65 91))
      (r (v4i:make 3 2 1 1))
      (o (v4i:zero)))
  (is (v4i:/! o v1 v2) r)
  (is o r)
  (is (v4i:/ v1 v2) r)
  (is (v4i:/ v1 v4i:+zero+) v4i:+zero+)
  (is (v4i:/ v4i:+zero+ v2) v4i:+zero+))

(diag "scalar product")
(let ((v (v4i:make 82 -53 11 31))
      (r (v4i:make 246 -159 33 93))
      (o (v4i:zero)))
  (is (v4i:scale! o v 3) r)
  (is o r)
  (is (v4i:scale v 3) r))

(diag "dot product")
(is (v4i:dot (v4i:make -21 39 35 82)
             (v4i:make -13 39 62 44))
    7572)
(is (v4i:dot (v4i:make 1 0 0 0) (v4i:make 0 1 0 0)) 0)
(is (v4i:dot (v4i:make 1 0 0 0) (v4i:make 0 0 1 0)) 0)
(is (v4i:dot (v4i:make 0 1 0 0) (v4i:make 0 0 1 0)) 0)
(is (v4i:dot (v4i:make 1 0 0 0) (v4i:make 1 0 0 0)) 1)
(is (v4i:dot (v4i:make 1 0 0 0) (v4i:make -1 0 0 0)) -1)

(diag "magnitude")
(is (v4i:magnitude v4i:+zero+) 0)
(is (v4i:magnitude (v4i:make 1 0 0 0)) 1)
(is (v4i:magnitude (v4i:make 32 25 19 26)) 51.826633)

(diag "abs")
(let ((v (v4i:make -42 -52 82 -9))
      (r (v4i:make 42 52 82 9))
      (o (v4i:zero)))
  (is (v4i:abs! o v) r)
  (is o r)
  (is (v4i:abs v) r))

(diag "negate")
(let ((v (v4i:make 78 95 -41 55))
      (r (v4i:make -78 -95 41 -55))
      (o (v4i:zero)))
  (is (v4i:negate! o v) r)
  (is o r)
  (is (v4i:negate v) r))

(diag "zero vector predicate")
(ok (v4i:zerop v4i:+zero+))
(ok (v4i:zerop (v4i:make 0 0 0 0)))

(diag "linear interpolation")
(let ((v1 (v4i:make 74 9 29 9))
      (v2 (v4i:make 19 98 64 98))
      (r (v4i:make 46 54 46 54))
      (o (v4i:zero)))
  (is (v4i:lerp! o v1 v2 0.5) r)
  (is o r)
  (is (v4i:lerp v1 v2 0.5) r)
  (is (v4i:lerp v1 v2 0.0) v1)
  (is (v4i:lerp v1 v2 1.0) v2))

(diag "comparators")
(let ((v1 (v4i:make 34 -49 87 91))
      (v2 (v4i:make 65 -11 -47 91))
      (v3 (v4i:make 97 83 98 92))
      (v4 (v4i:make 1 2 3 4))
      (v5 (v4i:make 2 3 4 5)))
  (ok (v4i:< v2 v3))
  (ok (v4i:<= v4 v4))
  (ok (v4i:<= v4 v5))
  (ok (v4i:> v3 v1))
  (ok (v4i:>= v4 v4))
  (ok (v4i:>= v5 v4)))

(diag "component-wise minimum")
(let* ((v1 (v4i:make 98 6 32 93))
       (v2 (v4i:make 87 25 76 31))
       (r (v4i:make (v4i:x v2) (v4i:y v1) (v4i:z v1) (v4i:w v2)))
       (o (v4i:zero)))
  (is (v4i:min! o v1 v2) r)
  (is o r)
  (is (v4i:min v1 v2) r))

(diag "component-wise maximum")
(let* ((v1 (v4i:make 64 38 25 45))
       (v2 (v4i:make 63 52 90 94))
       (r (v4i:make (v4i:x v1) (v4i:y v2) (v4i:z v2) (v4i:w v2)))
       (o (v4i:zero)))
  (is (v4i:max! o v1 v2) r)
  (is o r)
  (is (v4i:max v1 v2) r))

(finalize)
