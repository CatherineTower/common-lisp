(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 77)

(diag "accessors")
(let ((v (v2i:make 1 2)))
  (is (v2i:x v) 1)
  (is (v2i:y v) 2)
  (psetf (v2i:x v) 10
         (v2i:y v) 20)
  (is (v2i:x v) 10)
  (is (v2i:y v) 20))

(diag "copy")
(let ((v (v2i:make 1 2))
      (o (v2i:zero)))
  (is (v2i:copy! o v) v)
  (is o v)
  (is (v2i:copy v) v)
  (isnt v (v2i:copy v) :test #'eq))

(diag "clamp")
(let ((v (v2i:make -15 33))
      (r (v2i:make -1 1))
      (o (v2i:zero)))
  (is (v2i:clamp! o v :min -1 :max 1) r)
  (is o r)
  (is (v2i:clamp v :min -1 :max 1) r)
  (is (v2i:clamp v) v))

(diag "zero")
(let ((v (v2i:make -72 57)))
  (is (v2i:zero! v) v2i:+zero+)
  (is v v2i:+zero+)
  (is (v2i:zero) v2i:+zero+))

(diag "one")
(let ((v (v2i:make -81 92))
      (r (v2i:make 1 1)))
  (is (v2i:one! v) r)
  (is v r)
  (is (v2i:one) r))

(diag "list conversion")
(is (v2i:to-list (v2i:make 1 2)) '(1 2))
(is (v2i:from-list '(1 2)) (v2i:make 1 2))

(diag "equality")
(let ((v (v2i:make 85 -48)))
  (ok (v2i:= v v)))

(diag "addition")
(let ((v1 (v2i:make 41 -87))
      (v2 (v2i:make 11 42))
      (r (v2i:make 52 -45))
      (o (v2i:zero)))
  (is (v2i:+! o v1 v2) r)
  (is o r)
  (is (v2i:+ v1 v2) r)
  (is (v2i:+ v1 v2i:+zero+) v1)
  (is (v2i:+ v2i:+zero+ v2) v2))

(diag "subtraction")
(let ((v1 (v2i:make -16 -72))
      (v2 (v2i:make -69 61))
      (r (v2i:make 53 -133))
      (o (v2i:zero)))
  (is (v2i:-! o v1 v2) r)
  (is o r)
  (is (v2i:- v1 v2) r)
  (is (v2i:- v1 v2i:+zero+) v1))

(diag "hadamard product")
(let ((v1 (v2i:make -62 -80))
      (v2 (v2i:make 66 -21))
      (r (v2i:make -4092 1680))
      (o (v2i:zero)))
  (is (v2i:*! o v1 v2) r)
  (is o r)
  (is (v2i:* v1 v2) r)
  (is (v2i:* v1 v2i:+zero+) v2i:+zero+)
  (is (v2i:* v2i:+zero+ v2) v2i:+zero+))

(diag "hadamard quotient")
(let ((v1 (v2i:make 94 40))
      (v2 (v2i:make 32 17))
      (r (v2i:make 3 2))
      (o (v2i:zero)))
  (is (v2i:/! o v1 v2) r)
  (is o r)
  (is (v2i:/ v1 v2) r)
  (is (v2i:/ v1 v2i:+zero+) v2i:+zero+)
  (is (v2i:/ v2i:+zero+ v2) v2i:+zero+))

(diag "scalar product")
(let ((v (v2i:make 82 -53))
      (r (v2i:make 246 -159))
      (o (v2i:zero)))
  (is (v2i:scale! o v 3) r)
  (is o r)
  (is (v2i:scale v 3) r))

(diag "dot product")
(is (v2i:dot (v2i:make -21 39)
            (v2i:make -13 39))
    1794)
(is (v2i:dot (v2i:make 1 0) (v2i:make 0 1)) 0)
(is (v2i:dot (v2i:make 1 0) (v2i:make 1 0)) 1)
(is (v2i:dot (v2i:make 1 0) (v2i:make -1 0)) -1)

(diag "magnitude")
(is (v2i:magnitude v2i:+zero+) 0)
(is (v2i:magnitude (v2i:make 1 0)) 1)
(is (v2i:magnitude (v2i:make 32 25)) 40.60788)

(diag "abs")
(let ((v (v2i:make -42 -52))
      (r (v2i:make 42 52))
      (o (v2i:zero)))
  (is (v2i:abs! o v) r)
  (is o r)
  (is (v2i:abs v) r))

(diag "negate")
(let ((v (v2i:make 78 95))
      (r (v2i:make -78 -95))
      (o (v2i:zero)))
  (is (v2i:negate! o v) r)
  (is o r)
  (is (v2i:negate v) r))

(diag "angle")
(let ((angle (v2i:angle (v2i:make 0 1) (v2i:make 1 0))))
  (ok (<= (abs (- angle (/ pi 2))) 1e-7)))
(let ((angle (v2i:angle (v2i:make 1 0) (v2i:make 1 1))))
  (ok (<= (abs (- angle (/ pi 4))) 1e-7)))

(diag "zero vector predicate")
(ok (v2i:zerop v2i:+zero+))
(ok (v2i:zerop (v2i:make 0 0)))

(diag "linear interpolation")
(let ((v1 (v2i:make 74 9))
      (v2 (v2i:make 19 98))
      (r (v2i:make 46 54))
      (o (v2i:zero)))
  (is (v2i:lerp! o v1 v2 0.5) r)
  (is o r)
  (is (v2i:lerp v1 v2 0.5) r)
  (is (v2i:lerp v1 v2 0.0) v1)
  (is (v2i:lerp v1 v2 1.0) v2))

(diag "comparators")
(let ((v1 (v2i:make 34 -49))
      (v2 (v2i:make 65 -11))
      (v3 (v2i:make 97 83))
      (v4 (v2i:make 1 2))
      (v5 (v2i:make 3 4)))
  (ok (v2i:< v2 v3))
  (ok (v2i:<= v4 v4))
  (ok (v2i:<= v4 v5))
  (ok (v2i:> v3 v1))
  (ok (v2i:>= v4 v4))
  (ok (v2i:>= v5 v4)))

(diag "component-wise minimum")
(let* ((v1 (v2i:make 98 6))
       (v2 (v2i:make 87 25))
       (r (v2i:make (v2i:x v2) (v2i:y v1)))
       (o (v2i:zero)))
  (is (v2i:min! o v1 v2) r)
  (is o r)
  (is (v2i:min v1 v2) r))

(diag "component-wise maximum")
(let* ((v1 (v2i:make 64 38))
       (v2 (v2i:make 63 52))
       (r (v2i:make (v2i:x v1) (v2i:y v2)))
       (o (v2i:zero)))
  (is (v2i:max! o v1 v2) r)
  (is o r)
  (is (v2i:max v1 v2) r))

(finalize)
