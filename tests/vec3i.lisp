(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 87)

(diag "accessors")
(let ((v (v3i:make 1 2 3)))
  (is (v3i:x v) 1)
  (is (v3i:y v) 2)
  (is (v3i:z v) 3)
  (psetf (v3i:x v) 10
         (v3i:y v) 20
         (v3i:z v) 30)
  (is (v3i:x v) 10)
  (is (v3i:y v) 20)
  (is (v3i:z v) 30))

(diag "copy")
(let ((v (v3i:make 1 2 3))
      (o (v3i:zero)))
  (is (v3i:copy! o v) v)
  (is o v)
  (is (v3i:copy v) v)
  (isnt v (v3i:copy v) :test #'eq))

(diag "clamp")
(let ((v (v3i:make -15 33 152))
      (r (v3i:make -1 1 1))
      (o (v3i:zero)))
  (is (v3i:clamp! o v :min -1 :max 1) r)
  (is o r)
  (is (v3i:clamp v :min -1 :max 1) r)
  (is (v3i:clamp v) v))

(diag "zero")
(let ((v (v3i:make -72 57 87)))
  (is (v3i:zero! v) v3i:+zero+)
  (is v v3i:+zero+)
  (is (v3i:zero) v3i:+zero+))

(diag "list conversion")
(is (v3i:to-list (v3i:make 1 2 3)) '(1 2 3))
(is (v3i:from-list '(1 2 3)) (v3i:make 1 2 3))

(diag "equality")
(let ((v (v3i:make 85 -48 -38)))
  (ok (v3i:= v v)))

(diag "addition")
(let ((v1 (v3i:make 41 -87 -62))
      (v2 (v3i:make 11 42 73))
      (r (v3i:make 52 -45 11))
      (o (v3i:zero)))
  (is (v3i:+! o v1 v2) r)
  (is o r)
  (is (v3i:+ v1 v2) r)
  (is (v3i:+ v1 v3i:+zero+) v1)
  (is (v3i:+ v3i:+zero+ v2) v2))

(diag "subtraction")
(let ((v1 (v3i:make -16 -72 -89))
      (v2 (v3i:make -69 61 -78))
      (r (v3i:make 53 -133 -11))
      (o (v3i:zero)))
  (is (v3i:-! o v1 v2) r)
  (is o r)
  (is (v3i:- v1 v2) r)
  (is (v3i:- v1 v3i:+zero+) v1))

(diag "hadamard product")
(let ((v1 (v3i:make -62 -80 -6))
      (v2 (v3i:make 66 -21 14))
      (r (v3i:make -4092 1680 -84))
      (o (v3i:zero)))
  (is (v3i:*! o v1 v2) r)
  (is o r)
  (is (v3i:* v1 v2) r)
  (is (v3i:* v1 v3i:+zero+) v3i:+zero+)
  (is (v3i:* v3i:+zero+ v2) v3i:+zero+))

(diag "hadamard quotient")
(let ((v1 (v3i:make 94 40 -72))
      (v2 (v3i:make 32 17 65))
      (r (v3i:make 3 2 -1))
      (o (v3i:zero)))
  (is (v3i:/! o v1 v2) r)
  (is o r)
  (is (v3i:/ v1 v2) r)
  (is (v3i:/ v1 v3i:+zero+) v3i:+zero+)
  (is (v3i:/ v3i:+zero+ v2) v3i:+zero+))

(diag "scalar product")
(let ((v (v3i:make 82 -53 11))
      (r (v3i:make 246 -159 33))
      (o (v3i:zero)))
  (is (v3i:scale! o v 3) r)
  (is o r)
  (is (v3i:scale v 3) r))

(diag "dot product")
(is (v3i:dot (v3i:make -21 39 35)
             (v3i:make -13 39 62))
    3964)
(is (v3i:dot (v3i:make 1 0 0) (v3i:make 0 1 0)) 0)
(is (v3i:dot (v3i:make 1 0 0) (v3i:make 0 0 1)) 0)
(is (v3i:dot (v3i:make 0 1 0) (v3i:make 0 0 1)) 0)
(is (v3i:dot (v3i:make 1 0 0) (v3i:make 1 0 0)) 1)
(is (v3i:dot (v3i:make 1 0 0) (v3i:make -1 0 0)) -1)

(diag "magnitude")
(is (v3i:magnitude v3i:+zero+) 0)
(is (v3i:magnitude (v3i:make 1 0 0)) 1)
(is (v3i:magnitude (v3i:make 32 25 19)) 44.833023)

(diag "abs")
(let ((v (v3i:make -42 -52 82))
      (r (v3i:make 42 52 82))
      (o (v3i:zero)))
  (is (v3i:abs! o v) r)
  (is o r)
  (is (v3i:abs v) r))

(diag "negate")
(let ((v (v3i:make 78 95 -41))
      (r (v3i:make -78 -95 41))
      (o (v3i:zero)))
  (is (v3i:negate! o v) r)
  (is o r)
  (is (v3i:negate v) r))

(diag "cross product")
(let ((v1 (v3i:make 1 0 0))
      (v2 (v3i:make 0 1 0))
      (o (v3i:zero)))
  (is (v3i:cross! o v1 v2) (v3i:make 0 0 1))
  (is o (v3i:make 0 0 1))
  (is (v3i:cross (v3i:make 1 0 0) (v3i:make 0 1 0)) (v3i:make 0 0 1))
  (is (v3i:cross (v3i:make 1 0 0) (v3i:make 0 0 1)) (v3i:make 0 -1 0))
  (is (v3i:cross (v3i:make 0 1 0) (v3i:make 1 0 0)) (v3i:make 0 0 -1))
  (is (v3i:cross (v3i:make 0 1 0) (v3i:make 0 0 1)) (v3i:make 1 0 0))
  (is (v3i:cross (v3i:make 0 0 1) (v3i:make 1 0 0)) (v3i:make 0 1 0))
  (is (v3i:cross (v3i:make 0 0 1) (v3i:make 0 1 0)) (v3i:make -1 0 0)))

(diag "angle")
(let ((angle (v3i:angle (v3i:make 0 1 0) (v3i:make 1 0 1))))
  (ok (<= (abs (- angle (/ pi 2))) 1e-7)))
(let ((angle (v3i:angle (v3i:make 1 1 0) (v3i:make 1 0 1))))
  (ok (<= (abs (- angle (/ pi 3))) 1e-7)))
(let ((angle (v3i:angle (v3i:make 1 0 0) (v3i:make 1 1 0))))
  (ok (<= (abs (- angle (/ pi 4))) 1e-7)))

(diag "zero vector predicate")
(ok (v3i:zerop v3i:+zero+))
(ok (v3i:zerop (v3i:make 0 0 0)))

(diag "linear interpolation")
(let ((v1 (v3i:make 74 9 29))
      (v2 (v3i:make 19 98 64))
      (r (v3i:make 46 54 46))
      (o (v3i:zero)))
  (is (v3i:lerp! o v1 v2 0.5) r)
  (is o r)
  (is (v3i:lerp v1 v2 0.5) r)
  (is (v3i:lerp v1 v2 0.0) v1)
  (is (v3i:lerp v1 v2 1.0) v2))

(diag "comparators")
(let ((v1 (v3i:make 34 -49 87))
      (v2 (v3i:make 65 -11 -47))
      (v3 (v3i:make 97 83 98))
      (v4 (v3i:make 1 2 3))
      (v5 (v3i:make 2 3 4)))
  (ok (v3i:< v2 v3))
  (ok (v3i:<= v4 v4))
  (ok (v3i:<= v4 v5))
  (ok (v3i:> v3 v1))
  (ok (v3i:>= v4 v4))
  (ok (v3i:>= v5 v4)))

(diag "component-wise minimum")
(let* ((v1 (v3i:make 98 6 32))
       (v2 (v3i:make 87 25 76))
       (r (v3i:make (v3i:x v2) (v3i:y v1) (v3i:z v1)))
       (o (v3i:zero)))
  (is (v3i:min! o v1 v2) r)
  (is o r)
  (is (v3i:min v1 v2) r))

(diag "component-wise maximum")
(let* ((v1 (v3i:make 64 38 25))
       (v2 (v3i:make 63 52 90))
       (r (v3i:make (v3i:x v1) (v3i:y v2) (v3i:z v2)))
       (o (v3i:zero)))
  (is (v3i:max! o v1 v2) r)
  (is o r)
  (is (v3i:max v1 v2) r))

(finalize)
