(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 111)

(diag "identity")
(let ((m (m4:id))
      (r (m4:make 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1)))
  (is m r)
  (is m4:+id+ r))

(diag "copy")
(let ((m m4:+id+)
      (o (m4:zero)))
  (is (m4:copy! o m) m4:+id+)
  (is o m4:+id+)
  (is (m4:copy m) m4:+id+)
  (isnt m (m4:copy m) :test #'eq))

(diag "clamp")
(let ((m (m4:make 1 -2 3 -4 5 -6 7 -8 9 -10 11 -12 13 -14 15 -16))
      (o (m4:zero))
      (r (m4:make 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1 1 -1)))
  (is (m4:clamp! o m :min -1.0 :max 1.0) r)
  (is o r)
  (is (m4:clamp m :min -1.0 :max 1.0) r)
  (is (m4:clamp m) m))

(diag "multiplication")
(let ((m1 (m4:make 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16))
      (m2 (m4:make 10 50 90 130 20 60 100 140 30 70 110 150 40 80 120 160))
      (m3 m4:+id+)
      (r (m4:make 90 202 314 426 100 228 356 484 110 254 398 542 120 280 440
                    600))
      (rot-x (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0)))
      (rot-y (m4:rotate m4:+id+ (v3:make 0 (/ pi 4) 0)))
      (rot-xy (m4:rotate m4:+id+ (v3:make (/ pi 3) (/ pi 4) 0)))
      (tr1 (m4:translate m4:+id+ (v3:make 5 10 15)))
      (tr2 (m4:translate m4:+id+ (v3:make 10 20 30)))
      (o (m4:zero)))
  (is (m4:*! o m1 m1) r)
  (is o r)
  (is (m4:* m1 m3) m1)
  (is (m4:* m3 m1) m1)
  (is (m4:* m1 m2) (m4:* m2 m1))
  (is (m4:* rot-x rot-y) rot-xy)
  (isnt (m4:* rot-x rot-y) (m4:* rot-y rot-x))
  (is (m4:translation-to-vec3 (m4:* tr1 rot-xy)) (m4:translation-to-vec3 tr1))
  (is (m4:translation-to-vec3 (m4:* tr1 tr2)) (v3:make 15 30 45))
  (is (m4:translation-to-vec3 (m4:* tr2 tr1)) (v3:make 15 30 45)))

(diag "translation conversion")
(let ((m (m4:make 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16))
      (rm (m4:make 1 0 0 5 0 1 0 10 0 0 1 15 0 0 0 1))
      (om (m4:id))
      (v (v3:make 5 10 15))
      (rv (v3:make 13 14 15))
      (ov (v3:zero)))
  (is (m4:translation-from-vec3! om v) rm)
  (is om rm)
  (is (m4:translation-from-vec3 om v) rm)
  (is (m4:translation-to-vec3! ov m) rv)
  (is ov rv)
  (is (m4:translation-to-vec3 m) rv))

(diag "translate")
(let ((m (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0)))
      (o (m4:id))
      (r (m4:make 1 0 0 5 0 0.5 -0.86602545 10 0 0.86602545 0.5 15 0 0 0 1))
      (v (v3:make 5 10 15)))
  (ok (m4:~ (m4:translate! o m v) r))
  (ok (m4:~ o r))
  (is (m4:translation-to-vec3 (m4:translate m4:+id+ v)) v)
  (is (m4:translation-to-vec3 (m4:translate m v)) v))

(diag "rotation copy")
(let ((m (m4:make 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16))
      (r (m4:make 1 5 9 0 2 6 10 0 3 7 11 0 0 0 0 1))
      (o (m4:id)))
  (is (m4:copy-rotation! o m) r)
  (is o r)
  (is (m4:copy-rotation m) r))

(diag "rotation conversion")
(let ((m (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0)))
      (rmx m4:+id+)
      (rmy (m4:make 1 0 0 0 0 0.5 0 0 0 0.86602545 1 0 0 0 0 1))
      (rmz (m4:make 1 0 0 0 0 1 -0.86602545 0 0 0 0.5 0 0 0 0 1))
      (omx (m4:id))
      (omy (m4:id))
      (omz (m4:id))
      (rvx (v3:make 1 0 0))
      (rvy (v3:make 0 0.5 0.86602545))
      (rvz (v3:make 0 -0.86602545 0.5))
      (ovx (v3:zero))
      (ovy (v3:zero))
      (ovz (v3:zero)))
  (is (m4:rotation-axis-to-vec3! ovx m :x) rvx)
  (ok (v3:~ (m4:rotation-axis-to-vec3! ovy m :y) rvy))
  (ok (v3:~ (m4:rotation-axis-to-vec3! ovz m :z) rvz))
  (ok (v3:~ ovx rvx))
  (ok (v3:~ ovy rvy))
  (ok (v3:~ ovz rvz))
  (is (m4:rotation-axis-to-vec3 m :x) rvx)
  (ok (v3:~ (m4:rotation-axis-to-vec3 m :y) rvy))
  (ok (v3:~ (m4:rotation-axis-to-vec3 m :z) rvz))
  (is (m4:rotation-axis-from-vec3! omx rvx :x) rmx)
  (ok (m4:~ (m4:rotation-axis-from-vec3! omy rvy :y) rmy))
  (ok (m4:~ (m4:rotation-axis-from-vec3! omz rvz :z) rmz))
  (ok (m4:~ omx rmx))
  (ok (m4:~ omy rmy))
  (ok (m4:~ omz rmz))
  (is (m4:rotation-axis-from-vec3 m4:+id+ rvx :x) rmx)
  (ok (m4:~ (m4:rotation-axis-from-vec3 m4:+id+ rvy :y) rmy))
  (ok (m4:~ (m4:rotation-axis-from-vec3 m4:+id+ rvz :z) rmz)))

(diag "rotation")
(let ((omx (m4:id))
      (omy (m4:id))
      (omz (m4:id))
      (rmx (m4:make 1 0 0 0 0 0.5 -0.86602545 0 0 0.86602545 0.5 0 0 0 0 1))
      (rmy (m4:make 0.5 0 0.86602545 0 0 1 0 0 -0.86602545 0 0.5 0 0 0 0 1))
      (rmz (m4:make 0.5 -0.86602545 0 0 0.86602545 0.5 0 0 0 0 1 0 0 0 0 1))
      (vx (v3:make (/ pi 3) 0 0))
      (vy (v3:make 0 (/ pi 3) 0))
      (vz (v3:make 0 0 (/ pi 3))))
  (ok (m4:~ (m4:rotate! omx m4:+id+ vx) rmx))
  (ok (m4:~ (m4:rotate! omy m4:+id+ vy) rmy))
  (ok (m4:~ (m4:rotate! omz m4:+id+ vz) rmz))
  (ok (m4:~ omx rmx))
  (ok (m4:~ omy rmy))
  (ok (m4:~ omz rmz))
  (ok (m4:~ (m4:rotate m4:+id+ vx) rmx))
  (ok (m4:~ (m4:rotate m4:+id+ vy) rmy))
  (ok (m4:~ (m4:rotate m4:+id+ vz) rmz)))

(diag "scaling")
(let ((m (m4:make 10 0 0 0 0 20 0 0 0 0 30 0 0 0 0 1))
      (o (m4:id))
      (s (m4:make 10 0 0 0 0 40 0 0 0 0 90 0 0 0 0 1))
      (v (v3:make 1 2 3)))
  (ok (m4:= (m4:scale! o m v) s))
  (ok (m4:= o s))
  (is (m4:scale-to-vec3 (m4:scale m4:+id+ v)) v))

(diag "matrix * vec4 multiplication")
(let ((m (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0)))
      (v (v4:make 1 2 3 4))
      (o (v4:zero))
      (rv (v4:make 1.0 -1.5980763 3.232051 4.0)))
  (is (m4:*v4! o m v) rv)
  (is o rv)
  (is (m4:*v4 m v) rv)
  (is (m4:*v4 m4:+id+ v) v)
  (is (m4:*v4 m4:+id+ v4:+zero+) v4:+zero+))

(diag "transpose")
(let ((m (m4:make 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16))
      (r (m4:make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))
      (o (m4:id)))
  (is (m4:transpose! o m) r)
  (is o r)
  (is (m4:transpose m) r)
  (is (m4:transpose m4:+id+) m4:+id+))

(diag "orthogonality predicate")
(ok (m4:orthogonalp (m4:rotate m4:+id+ (v3:make pi 0 0))))
(ok (m4:orthogonalp (m4:rotate m4:+id+ (v3:make (/ pi 2) 0 0))))
(ok (m4:orthogonalp (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0))))
(ok (m4:orthogonalp (m4:rotate m4:+id+ (v3:make (/ pi 4) 0 0))))
(ok (m4:orthogonalp (m4:rotate m4:+id+ (v3:make (/ pi 5) 0 0))))
(ok (m4:orthogonalp (m4:rotate m4:+id+ (v3:make (/ pi 6) 0 0))))

(diag "orthogonalization")
(let ((m (m4:make 0 1 -0.12988785 1.0139829 0 0 0.3997815 -0.027215311 1 0
                    0.5468181 0.18567966 0 0 0 0))
      (o (m4:id))
      (r (m4:make 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 1)))
  (is (m4:orthonormalize! o m) r)
  (is o r)
  (is (m4:orthonormalize m) r))

(diag "trace")
(is (m4:trace (m4:zero)) 0)
(is (m4:trace m4:+id+) 4)
(is (m4:trace (m4:make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)) 34)

(diag "diagonal")
(let ((m (m4:make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))
      (r1 (v4:make 1 6 11 16))
      (r2 (v4:make 4 7 10 13))
      (o (v4:zero)))
  (ok (m4:diagonalp (m4:id)))
  (ok (not (m4:diagonalp m)))
  (is (m4:main-diagonal! o m) r1)
  (is o r1)
  (is (m4:main-diagonal m) r1)
  (is (m4:anti-diagonal! o m) r2)
  (is o r2)
  (is (m4:anti-diagonal m) r2))

(diag "determinant")
(is (m4:determinant (m4:make 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16)) 0)
(is (m4:determinant m4:+id+) 1)
(is (m4:determinant (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0))) 1)
(is (m4:determinant (m4:make 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1)) -1)

(diag "inversion")
(let ((m (m4:rotate m4:+id+ (v3:make (/ pi 3) 0 0)))
      (r (m4:rotate m4:+id+ (v3:make (/ pi -3) 0 0)))
      (o (m4:id)))
  (is (m4:invert! o m) r)
  (is o r)
  (is (m4:invert m) r)
  (is (m4:invert m4:+id+) m4:+id+)
  (is-error (m4:invert (m4:make 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16))
            simple-error))

(diag "view matrix")
(let ((o (m4:id))
      (r (m4:make -0.7071068 0 -0.7071068 0.7071068 0 1 0 0 0.7071068 0
                    -0.7071068 -0.7071068 0 0 0 1)))
  (ok (m4:~ (m4:view! o (v3:make 1 0 0) (v3:make 0 0 1) (v3:make 0 1 0)) r))
  (ok (m4:~ o r))
  (ok (m4:~ (m4:view (v3:make 1 0 0) (v3:make 0 0 1) (v3:make 0 1 0)) r))
  (is (m4:view v3:+zero+ v3:+zero+ v3:+zero+)
      (m4:make 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1)))

(diag "orthographic projection matrix")
(let ((r (m4:make 0.05 0 0 0 0 0.1 0 0 0 0 -0.002 -1 0 0 0 1))
      (o (m4:id)))
  (is (m4:orthographic-projection! o -20 20 -10 10 0 1000) r)
  (is o r)
  (is (m4:orthographic-projection -20 20 -10 10 0 1000) r))

(diag "perspective projection matrix")
(let ((r (m4:make 0.97427857 0 0 0 0 1.7320508 0 0 0 0 -1.002002 -2.002002 0 0
                    -1 0))
      (o (m4:id)))
  (is (m4:perspective-projection! o (/ pi 3) (/ 16 9) 1 1000) r)
  (is o r)
  (is (m4:perspective-projection (/ pi 3) (/ 16 9) 1 1000) r))

(finalize)
