(in-package :gamebox-math.test)

(setf *default-test-function* #'equalp)

(plan 104)

(diag "structure")
(is-type +zero-vec2+ '(simple-array single-float (2)))
(is-type (vec2 0 0) '(simple-array single-float (2)))

(diag "accessors")
(is (v2ref (v2zero) 0) 0)
(is (v2ref (v2zero) 1) 0)
(let ((v (v2zero)))
  (psetf (v2ref v 0) 10.0 (v2ref v 1) 20.0)
  (is (v2ref v 0) 10)
  (is (v2ref v 1) 20))
(with-vec2 (v (vec2 1 2))
  (is vx 1)
  (is vy 2)
  (psetf vx 10.0 vy 20.0)
  (is vx 10)
  (is vy 20))
(with-vec2s ((v1 (vec2 1 2)) (v2 (vec2 3 4)))
  (is v1x 1)
  (is v1y 2)
  (is v2x 3)
  (is v2y 4)
  (psetf v1x 10.0 v1y 20.0 v2x 30.0 v2y 40.0)
  (is v1x 10)
  (is v1y 20)
  (is v2x 30)
  (is v2y 40))

(diag "copy")
(with-vec2s ((v (vec2 1 2))
             (o (v2zero)))
  (is (v2cp! o v) v)
  (is o v)
  (is (v2cp v) v)
  (isnt v (v2cp v) :test #'eq))

(diag "clamp")
(with-vec2s ((v (vec2 -1.5185602 0.3374052))
             (r (vec2 -1 0.3374052))
             (o (v2zero)))
  (is (v2clamp! o v :min -1.0 :max 1.0) r)
  (is o r)
  (is (v2clamp v :min -1.0 :max 1.0) r)
  (is (v2clamp v) v))

(diag "stabilize")
(with-vec2s ((v (vec2 1e-8 1e-8))
             (o (v2zero)))
  (is (v2stab! o v) +zero-vec2+)
  (is o +zero-vec2+)
  (is (v2stab v) +zero-vec2+))

(diag "zero")
(with-vec2 (v (vec2 -0.72470546 0.57963276))
  (is (v2zero! v) +zero-vec2+)
  (is v +zero-vec2+)
  (is (v2zero) +zero-vec2+))

(diag "list conversion")
(is (v2->list (vec2 1 2)) '(1 2))
(is (list->v2 '(1 2)) (vec2 1 2))

(diag "equality")
(with-vec2s ((v1 (vec2 0.8598654 -0.4803753))
             (v2 (vec2 1e-8 1e-8)))
  (ok (v2= v1 v1))
  (ok (v2~ (v2+ v1 v2) v1))
  (ok (v2~ v2 +zero-vec2+)))

(diag "addition")
(with-vec2s ((v1 (vec2 0.4110496 -0.87680984))
             (v2 (vec2 0.1166687 0.42538047))
             (r (vec2 0.5277183 -0.45142937))
             (o (v2zero)))
  (is (v2+! o v1 v2) r)
  (is o r)
  (is (v2+ v1 v2) r)
  (is (v2+ v1 +zero-vec2+) v1)
  (is (v2+ +zero-vec2+ v2) v2))

(diag "subtraction")
(with-vec2s ((v1 (vec2 -0.16772795 -0.7287135))
             (v2 (vec2 -0.69658303 0.6168339))
             (r (vec2 0.5288551 -1.3455474))
             (o (v2zero)))
  (is (v2-! o v1 v2) r)
  (is o r)
  (is (v2- v1 v2) r)
  (is (v2- v1 +zero-vec2+) v1))

(diag "hadamard product")
(with-vec2s ((v1 (vec2 -0.6219859 -0.80110574))
             (v2 (vec2 0.6687746 -0.21906853))
             (r (vec2 -0.4159684 0.17549706))
             (o (v2zero)))
  (is (v2had*! o v1 v2) r)
  (is o r)
  (is (v2had* v1 v2) r)
  (is (v2had* v1 +zero-vec2+) +zero-vec2+)
  (is (v2had* +zero-vec2+ v2) +zero-vec2+))

(diag "hadamard quotient")
(with-vec2s ((v1 (vec2 0.9498384 0.4066379))
             (v2 (vec2 0.32331443 0.17439032))
             (r (vec2 2.9378164 2.3317688))
             (o (v2zero)))
  (is (v2had/! o v1 v2) r)
  (is o r)
  (is (v2had/ v1 v2) r)
  (is (v2had/ v1 +zero-vec2+) +zero-vec2+)
  (is (v2had/ +zero-vec2+ v2) +zero-vec2+))

(diag "scalar product")
(with-vec2s ((v (vec2 0.82007027 -0.53582144))
             (r (vec2 0.7762602 -0.5071966))
             (o (v2zero)))
  (is (v2scale! o v 0.94657767) r)
  (is o r)
  (is (v2scale v 0.94657767) r))

(diag "dot product")
(is (v2dot (vec2 -0.21361923 0.39387107)
           (vec2 -0.13104868 0.399935))
    0.18551734)
(is (v2dot (vec2 1 0) (vec2 0 1)) 0)
(is (v2dot (vec2 1 0) (vec2 1 0)) 1)
(is (v2dot (vec2 1 0) (vec2 -1 0)) -1)

(diag "magnitude")
(is (v2mag +zero-vec2+) 0)
(is (v2mag (vec2 1 0)) 1)
(is (v2mag (vec2 0.32979298 0.2571392)) 0.4181913)

(diag "normalize")
(with-vec2s ((v (vec2 -0.6589291 0.23270178))
             (r (vec2 -0.942928 0.3329964))
             (o (v2zero)))
  (is (v2normalize! o v) r)
  (is o r)
  (is (v2normalize v) r)
  (is (v2normalize (vec2 2 0)) (vec2 1 0))
  (is (v2normalize (vec2 0 2)) (vec2 0 1))
  (is (v2normalize (vec2 0 0)) (vec2 0 0)))

(diag "round")
(with-vec2s ((v (vec2 -0.70498157 0.3615427))
             (r (vec2 -1 0))
             (o (v2zero)))
  (is (v2round! o v) r)
  (is o r)
  (is (v2round v) r))

(diag "abs")
(with-vec2s ((v (vec2 -0.4241562 -0.52400947))
             (r (vec2 0.4241562 0.52400947))
             (o (v2zero)))
  (is (v2abs! o v) r)
  (is o r)
  (is (v2abs v) r))

(diag "negate")
(with-vec2s ((v (vec2 0.7823446 0.95027566))
             (r (vec2 -0.7823446 -0.95027566))
             (o (v2zero)))
  (is (v2neg! o v) r)
  (is o r)
  (is (v2neg v) r))

(diag "angle")
(let ((angle (v2angle (vec2 0 1) (vec2 1 0))))
  (ok (<= (abs (- angle (/ pi 2))) 1e-7)))
(let ((angle (v2angle (vec2 1 0) (vec2 1 1))))
  (ok (<= (abs (- angle (/ pi 4))) 1e-7)))

(diag "zero vector predicate")
(ok (v2zerop +zero-vec2+))
(ok (v2zerop (vec2 0 0)))

(diag "direction equality")
(ok (v2dir= (vec2 0.0073252916 0) (vec2 0.31148136 0)))
(ok (v2dir= (vec2 0 0.6982585) (vec2 0 0.72258794)))

(diag "linear interpolation")
(with-vec2s ((v1 (vec2 0.74485755 0.092342734))
             (v2 (vec2 0.19426346 0.9881369))
             (r (vec2 0.4695605 0.5402398))
             (o (v2zero)))
  (is (v2lerp! o v1 v2 0.5) r)
  (is o r)
  (is (v2lerp v1 v2 0.5) r)
  (is (v2lerp v1 v2 0.0) v1)
  (is (v2lerp v1 v2 1.0) v2))

(diag "comparators")
(with-vec2s ((v1 (vec2 0.34003425 -0.4920528))
             (v2 (vec2 0.6535034 -0.11586404))
             (v3 (vec2 0.9715252 0.8300271))
             (v4 (vec2 1 2))
             (v5 (vec2 3 4)))
  (ok (v2< v2 v3))
  (ok (v2<= v4 v4))
  (ok (v2<= v4 v5))
  (ok (v2> v3 v1))
  (ok (v2>= v4 v4))
  (ok (v2>= v5 v4)))

(diag "component-wise minimum")
(with-vec2s ((v1 (vec2 0.98117805 0.06889212))
             (v2 (vec2 0.8774886 0.25179327))
             (r (vec2 v2x v1y))
             (o (v2zero)))
  (is (v2min! o v1 v2) r)
  (is o r)
  (is (v2min v1 v2) r))

(diag "component-wise maximum")
(with-vec2s ((v1 (vec2 0.64380646 0.38965714))
             (v2 (vec2 0.6341989 0.5274999))
             (r (vec2 v1x v2y))
             (o (v2zero)))
  (is (v2max! o v1 v2) r)
  (is o r)
  (is (v2max v1 v2) r))

(finalize)
