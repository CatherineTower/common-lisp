(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 62)

(diag "identity")
(let ((m (m3:id))
      (r (m3:make 1 0 0 0 1 0 0 0 1)))
  (is m r)
  (is m3:+id+ r))

(diag "copy")
(let ((m m3:+id+)
      (o (m3:zero)))
  (is (m3:copy! o m) m3:+id+)
  (is o m3:+id+)
  (is (m3:copy m) m3:+id+)
  (isnt m (m3:copy m) :test #'eq))

(diag "clamp")
(let ((m (m3:make 1 -2 3 -4 5 -6 7 -8 9))
      (o (m3:zero))
      (r (m3:make 1 -1 1 -1 1 -1 1 -1 1)))
  (is (m3:clamp! o m :min -1.0 :max 1.0) r)
  (is o r)
  (is (m3:clamp m :min -1.0 :max 1.0) r)
  (is (m3:clamp m) m))

(diag "multiplication")
(let ((m1 (m3:make 1 5 9 2 6 10 3 7 11))
      (m2 (m3:make 10 50 90 20 60 100 30 70 110))
      (m3 m3:+id+)
      (r (m3:make 38 98 158 44 116 188 50 134 218))
      (rot-z (m3:rotate m3:+id+ (/ pi 3)))
      (tr1 (m3:translate m3:+id+ (v2:make 5 10)))
      (tr2 (m3:translate m3:+id+ (v2:make 10 20)))
      (o (m3:zero)))
  (is (m3:*! o m1 m1) r)
  (is o r)
  (is (m3:* m1 m3) m1)
  (is (m3:* m3 m1) m1)
  (is (m3:* m1 m2) (m3:* m2 m1))
  (isnt (m3:* m1 rot-z) (m3:* rot-z m1))
  (is (m3:translation-to-vec2 (m3:* tr1 rot-z)) (m3:translation-to-vec2 tr1))
  (is (m3:translation-to-vec2 (m3:* tr1 tr2)) (v2:make 15 30))
  (is (m3:translation-to-vec2 (m3:* tr2 tr1)) (v2:make 15 30)))

(diag "translation conversion")
(let ((m (m3:make 1 5 9 2 6 10 3 7 11))
      (rm (m3:make 1 0 9 0 1 10 0 0 1))
      (om (m3:id))
      (v (v2:make 9 10))
      (rv (v2:make 9 10))
      (ov (v2:zero)))
  (is (m3:translation-from-vec2! om v) rm)
  (is om rm)
  (is (m3:translation-from-vec2 om v) rm)
  (is (m3:translation-to-vec2! ov m) rv)
  (is ov rv)
  (is (m3:translation-to-vec2 m) rv))

(diag "translate")
(let ((m (m3:rotate m3:+id+ (/ pi 3)))
      (v (v2:make 5 10)))
  (is (m3:translation-to-vec2 (m3:translate m3:+id+ v)) v)
  (is (m3:translation-to-vec2 (m3:translate m v)) v))

(diag "rotation copy")
(let ((m (m3:make 1 5 0 2 6 0 0 0 1))
      (r (m3:make 1 5 0 2 6 0 0 0 1))
      (o (m3:id)))
  (is (m3:copy-rotation! o m) r)
  (is o r)
  (is (m3:copy-rotation m) r))

(diag "rotation conversion")
(let ((rmx m3:+id+)
      (omx (m3:id))
      (rvx (v2:make 1 0)))
  (is (m3:rotation-axis-from-vec2! omx rvx :x) rmx)
  (ok (m3:~ omx rmx))
  (is (m3:rotation-axis-from-vec2 m3:+id+ rvx :x) rmx))

(diag "rotation")
(let ((omz (m3:id))
      (rmz (m3:make 0.5 -0.86602545 0 0.86602545 0.5 0 0 0 1))
      (z (/ pi 3)))
  (ok (m3:~ (m3:rotate! omz m3:+id+ z) rmz))
  (ok (m3:~ omz rmz))
  (ok (m3:~ (m3:rotate m3:+id+ z) rmz)))

(diag "scaling")
(let ((m (m3:make 10 0 0 0 20 0 0 0 30))
      (o (m3:id))
      (s (m3:make 10 0 0 0 40 0 0 0 30))
      (v (v2:make 1 2)))
  (ok (m3:= (m3:scale! o m v) s))
  (ok (m3:= o s))
  (is (m3:scale-to-vec2 (m3:scale m3:+id+ v)) v))

(diag "matrix * vec3 multiplication")
(let ((m (m3:rotate m3:+id+ (/ pi 3)))
      (v (v3:make 1 2 3))
      (o (v3:zero))
      (rv (v3:make -1.2320509 1.8660254 3)))
  (is (m3:*v3! o m v) rv)
  (is o rv)
  (is (m3:*v3 m v) rv)
  (is (m3:*v3 m3:+id+ v) v)
  (is (m3:*v3 m3:+id+ v3:+zero+) v3:+zero+))

(diag "transpose")
(let ((m (m3:make 1 5 9 2 6 10 3 7 11))
      (r (m3:make 1 2 3 5 6 7 9 10 11))
      (o (m3:id)))
  (is (m3:transpose! o m) r)
  (is o r)
  (is (m3:transpose m) r)
  (is (m3:transpose m3:+id+) m3:+id+))

(diag "orthogonality predicate")
(ok (m3:orthogonalp (m3:rotate m3:+id+ pi)))
(ok (m3:orthogonalp (m3:rotate m3:+id+ (/ pi 2))))
(ok (m3:orthogonalp (m3:rotate m3:+id+ (/ pi 3))))

(diag "trace")
(is (m3:trace (m3:zero)) 0)
(is (m3:trace m3:+id+) 3)
(is (m3:trace (m3:make 1 2 3 4 5 6 7 8 9)) 15)

(diag "diagonal")
(let ((m (m3:make 1 2 3 4 5 6 7 8 9))
      (r1 (v3:make 1 5 9))
      (r2 (v3:make 3 5 7))
      (o (v3:zero)))
  (ok (m3:diagonalp (m3:id)))
  (ok (not (m3:diagonalp m)))
  (is (m3:main-diagonal! o m) r1)
  (is o r1)
  (is (m3:main-diagonal m) r1)
  (is (m3:anti-diagonal! o m) r2)
  (is o r2)
  (is (m3:anti-diagonal m) r2))

(finalize)
