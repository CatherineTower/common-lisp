(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 44)

(diag "identity")
(is (dq:id) (dq:make (q:id) (q:zero)))

(diag "equality")
(pass "redundant")

(diag "copy")
(pass "redundant")

(diag "addition")
(pass "redundant")

(diag "subtraction")
(pass "redundant")

(diag "multiplication")
(pass "redundant")

(diag "scalar product")
(pass "redundant")

(diag "conjugate")
(pass "redundant")

(diag "magnitude")
(pass "redundant")

(diag "normalize")
(let ((d (dq:make (q:make -0.6114731 0.9762738 0.2938311 0.28761292)
                  (q:make -0.22068572 -0.499269 0.2683978 0.05499983)))
      (r (dq:make (q:make -0.4999214 0.79817116 0.2402272 0.2351434)
                  (q:make -0.1804258 -0.40818685 0.21943371 0.044966154)))
      (o (dq:id)))
  (is (dq:normalize! o d) r)
  (is o r)
  (is (dq:normalize d) r)
  (is (dq:normalize (dq:make (q:make 2 0 0 0) (q:zero))) (dq:id)))

(diag "negate")
(pass "redundant")

(diag "dot product")
(pass "redundant")

(diag "inverse")
(let ((d (dq:make (q:make 0.80088806 0.9623561 -0.86221576 -0.34557796)
                  (q:make 0.7549772 -0.49641347 0.5262337 -0.15916371)))
      (r (dq:make (q:make 0.32953054 -0.39596757 0.3547642 0.14219026)
                  (q:make 0.38434494 0.115688086 -0.13717361 0.09729204)))
      (o (dq:id)))
  (is (dq:inverse! o d) r)
  (is o r)
  (is (dq:inverse d) r))

(diag "translation conversion")
(let ((d (dq:make (q:make 0.8660254 0.5 0 0)
                  (q:make -2.0669873 4.580127 16.160254 7.9903812)))
      (rd (dq:make (q:make 1 0 0 0)
                   (q:make 0.0 5.0 10.0 15.0)))
      (od (dq:id))
      (rv (v3:make 10 20 30))
      (ov (v3:zero)))
  (ok (v3:~ (dq:translation-to-vec3! ov d) rv :tolerance 1e-5))
  (ok (v3:~ ov rv :tolerance 1e-5))
  (ok (v3:~ (dq:translation-to-vec3 d) rv :tolerance 1e-5))
  (is (dq:translation-from-vec3! od rv) rd)
  (is od rd)
  (is (dq:translation-from-vec3 rv) rd))

(diag "rotation conversion")
(pass "redundant")

(diag "rotation")
(pass "redundant")

(diag "matrix conversion")
(let ((d (dq:make (q:make 0.8660254 0.5 0 0)
                  (q:make -2.0669873 4.580127 16.160254 7.9903812)))
      (r (m4:make 1 0 0 10 0 0.5 -0.8660254 20 0 0.8660254 0.5 30 0 0 0 1))
      (o (m4:id)))
  (ok (m4:~ (dq:to-mat4! o d) r :tolerance 1e-5))
  (ok (m4:~ o r :tolerance 1e-5))
  (ok (m4:~ (dq:to-mat4 d) r :tolerance 1e-5)))

(diag "screw parameter conversion")
(let ((d (dq:make (q:make 0.8660254 0.5 0 0)
                  (q:make -2.0669873 4.580127 16.160254 7.9903812)))
      (r (dq:make (q:make 0.8660254 0.5 0 0)
                  (q:make -2.4999998 4.330127 16.160254 7.9903817))))
  (multiple-value-bind (angle pitch dir moment) (dq:to-screw d)
    (ok (< (abs (- angle 1.0471976)) 1e-5))
    (ok (< (abs (- pitch 10)) 1e-5))
    (ok (v3:~ dir (v3:make 1 0 0) :tolerance 1e-5))
    (ok (v3:~ moment (v3:make 0 32.320507 15.980763) :tolerance 1e-5))
    (ok (dq:~ (dq:from-screw angle pitch dir moment) r :tolerance 1e-5))))

(diag "screw spherical linear interpolation")
(let ((d1 (dq:make (q:make 0.8660254 0.5 0 0)
                   (q:make -2.0669873 4.580127 16.160254 7.9903812)))
      (d2 (dq:make (q:make 0.9238795 0.38268346 0 0)
                   (q:make -3.3648949 9.430137 21.511862 12.737339)))
      (r (dq:make (q:make 0.89687264 0.44228896 0 0)
                  (q:make -2.868731 6.947688 18.876476 10.386089)))
      (o (dq:id)))
  (is (dq:sclerp! o d1 d2 0.5) r)
  (is o r)
  (is (dq:sclerp d1 d2 0.5) r)
  (is (dq:sclerp d1 d2 0.0) d1)
  (ok (dq:~ (dq:sclerp d1 d2 1.0) d2 :tolerance 1e-4)))

(diag "normalized linear interpolation")
(let ((d1 (dq:make (q:make 0.8660254 0.5 0 0)
                   (q:make -2.0669873 4.580127 16.160254 7.9903812)))
      (d2 (dq:make (q:make 0.9238795 0.38268346 0 0)
                   (q:make -3.3648949 9.430137 21.511862 12.737339)))
      (r (dq:make (q:make 0.8949524 0.44134173 0 0)
                  (q:make -2.715941 7.0051317 18.836058 10.36386)))
      (o (dq:id)))
  (is (dq:nlerp! o d1 d2 0.5) r)
  (is o r)
  (is (dq:nlerp d1 d2 0.5) r)
  (is (dq:nlerp d1 d2 0.0) d1)
  (is (dq:nlerp d1 d2 1.0) d2))

(finalize)
