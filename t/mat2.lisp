(in-package :box.math.test)

(setf *default-test-function* #'equalp)

(plan 48)

(diag "identity")
(let ((m (m2:id))
      (r (m2:matrix 1 0 0 1)))
  (is m r)
  (is m2:+id+ r))

(diag "copy")
(let ((m m2:+id+)
      (o (m2:zero)))
  (is (m2:copy! o m) m2:+id+)
  (is o m2:+id+)
  (is (m2:copy m) m2:+id+)
  (isnt m (m2:copy m) :test #'eq))

(diag "clamp")
(let ((m (m2:matrix 1 -2 3 -4))
      (o (m2:zero))
      (r (m2:matrix 1 -1 1 -1)))
  (is (m2:clamp! o m :min -1.0 :max 1.0) r)
  (is o r)
  (is (m2:clamp m :min -1.0 :max 1.0) r)
  (is (m2:clamp m) m))

(diag "multiplication")
(let ((m (m2:matrix 1 5 2 6))
      (r (m2:matrix 11 35 14 46))
      (rot-z (m2:rotate m2:+id+ (/ pi 3)))
      (o (m2:zero)))
  (is (m2:*! o m m) r)
  (is o r)
  (is (m2:* m m2:+id+) m)
  (is (m2:* m2:+id+ m) m)
  (is (m2:* m m2:+id+) (m2:* m2:+id+ m))
  (isnt (m2:* m rot-z) (m2:* rot-z m)))

(diag "rotation conversion")
(let ((rmx m2:+id+)
      (omx (m2:id))
      (rvx (v2:vec 1 0)))
  (is (m2:rotation-axis-from-vec2! omx rvx :x) rmx)
  (ok (m2:~ omx rmx))
  (is (m2:rotation-axis-from-vec2 m2:+id+ rvx :x) rmx))

(diag "rotation")
(let ((omz (m2:id))
      (rmz (m2:matrix 0.5 -0.86602545 0.86602545 0.5))
      (z (/ pi 3)))
  (ok (m2:~ (m2:rotate! omz m2:+id+ z) rmz))
  (ok (m2:~ omz rmz))
  (ok (m2:~ (m2:rotate m2:+id+ z) rmz)))

(diag "scaling")
(let ((m (m2:matrix 10 0 0 20))
      (o (m2:id))
      (s (m2:matrix 10 0 0 40))
      (v (v2:vec 1 2)))
  (ok (m2:= (m2:scale! o m v) s))
  (ok (m2:= o s))
  (is (m2:scale-to-vec2 (m2:scale m2:+id+ v)) v))

(diag "matrix * vec2 multiplication")
(let ((m (m2:rotate m2:+id+ (/ pi 3)))
      (v (v2:vec 1 2))
      (o (v2:zero))
      (rv (v2:vec -1.2320509 1.8660254)))
  (is (m2:*v2! o m v) rv)
  (is o rv)
  (is (m2:*v2 m v) rv)
  (is (m2:*v2 m2:+id+ v) v)
  (is (m2:*v2 m2:+id+ v2:+zero+) v2:+zero+))

(diag "transpose")
(let ((m (m2:matrix 1 5 2 6))
      (r (m2:matrix 1 2 5 6))
      (o (m2:id)))
  (is (m2:transpose! o m) r)
  (is o r)
  (is (m2:transpose m) r)
  (is (m2:transpose m2:+id+) m2:+id+))

(diag "orthogonality predicate")
(ok (m2:orthogonalp (m2:rotate m2:+id+ pi)))
(ok (m2:orthogonalp (m2:rotate m2:+id+ (/ pi 2))))
(ok (m2:orthogonalp (m2:rotate m2:+id+ (/ pi 3))))

(diag "trace")
(is (m2:trace (m2:zero)) 0)
(is (m2:trace m2:+id+) 2)
(is (m2:trace (m2:matrix 1 2 3 4)) 5)

(diag "diagonal")
(let ((m (m2:matrix 1 2 3 4))
      (r1 (v2:vec 1 4))
      (r2 (v2:vec 2 3))
      (o (v2:zero)))
  (ok (m2:diagonalp (m2:id)))
  (ok (not (m2:diagonalp m)))
  (is (m2:main-diagonal! o m) r1)
  (is o r1)
  (is (m2:main-diagonal m) r1)
  (is (m2:anti-diagonal! o m) r2)
  (is o r2)
  (is (m2:anti-diagonal m) r2))

(finalize)
