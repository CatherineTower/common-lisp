(in-package :gamebox-math.test)

(setf *default-test-function* #'equalp)

(plan 44)

(diag "identity")
(is (dqid) (dquat (qid) (qzero)))

(diag "equality")
(pass "redundant")

(diag "copy")
(pass "redundant")

(diag "addition")
(pass "redundant")

(diag "subtraction")
(pass "redundant")

(diag "multiplication")
(pass "redundant")

(diag "scalar product")
(pass "redundant")

(diag "conjugate")
(pass "redundant")

(diag "magnitude")
(pass "redundant")

(diag "normalize")
(let ((d (dquat (quat -0.6114731 0.9762738 0.2938311 0.28761292)
                (quat -0.22068572 -0.499269 0.2683978 0.05499983)))
      (r (dquat (quat -0.4999214 0.79817116 0.2402272 0.2351434)
                (quat -0.1804258 -0.40818685 0.21943371 0.044966154)))
      (o (dqid)))
  (is (dqnormalize! o d) r)
  (is o r)
  (is (dqnormalize d) r)
  (is (dqnormalize (dquat (quat 2 0 0 0) (qzero))) (dqid)))

(diag "negate")
(pass "redundant")

(diag "dot product")
(pass "redundant")

(diag "inverse")
(let ((d (dquat (quat 0.80088806 0.9623561 -0.86221576 -0.34557796)
                (quat 0.7549772 -0.49641347 0.5262337 -0.15916371)))
      (r (dquat (quat 0.32953054 -0.39596757 0.3547642 0.14219026)
                (quat 0.38434494 0.115688086 -0.13717361 0.09729204)))
      (o (dqid)))
  (is (dqinv! o d) r)
  (is o r)
  (is (dqinv d) r))

(diag "translation conversion")
(let ((d (dquat (quat 0.8660254 0.5 0 0)
                (quat -2.0669873 4.580127 16.160254 7.9903812)))
      (rd (dquat (quat 1 0 0 0)
                 (quat 0.0 5.0 10.0 15.0)))
      (od (dqid))
      (rv (vec3 10 20 30))
      (ov (v3zero)))
  (ok (v3~ (dqtr->v3! ov d) rv :tolerance 1e-5))
  (ok (v3~ ov rv :tolerance 1e-5))
  (ok (v3~ (dqtr->v3 d) rv :tolerance 1e-5))
  (is (v3->dqtr! od rv) rd)
  (is od rd)
  (is (v3->dqtr rv) rd))

(diag "rotation conversion")
(pass "redundant")

(diag "rotation")
(pass "redundant")

(diag "matrix conversion")
(let ((d (dquat (quat 0.8660254 0.5 0 0)
                (quat -2.0669873 4.580127 16.160254 7.9903812)))
      (r (mat4 1 0 0 10 0 0.5 -0.8660254 20 0 0.8660254 0.5 30 0 0 0 1))
      (o (m4id)))
  (ok (m4~ (dq->m4! o d) r :tolerance 1e-5))
  (ok (m4~ o r :tolerance 1e-5))
  (ok (m4~ (dq->m4 d) r :tolerance 1e-5)))

(diag "screw parameter conversion")
(let ((d (dquat (quat 0.8660254 0.5 0 0)
                (quat -2.0669873 4.580127 16.160254 7.9903812)))
      (r (dquat (quat 0.8660254 0.5 0 0)
                (quat -2.4999998 4.330127 16.160254 7.9903817))))
  (multiple-value-bind (angle pitch dir moment) (dq->screw d)
    (ok (< (abs (- angle 1.0471976)) 1e-5))
    (ok (< (abs (- pitch 10)) 1e-5))
    (ok (v3~ dir (vec3 1 0 0) :tolerance 1e-5))
    (ok (v3~ moment (vec3 0 32.320507 15.980763) :tolerance 1e-5))
    (ok (dq~ (screw->dq angle pitch dir moment) r :tolerance 1e-5))))

(diag "screw spherical linear interpolation")
(let ((d1 (dquat (quat 0.8660254 0.5 0 0)
                 (quat -2.0669873 4.580127 16.160254 7.9903812)))
      (d2 (dquat (quat 0.9238795 0.38268346 0 0)
                 (quat -3.3648949 9.430137 21.511862 12.737339)))
      (r (dquat (quat 0.89687264 0.44228896 0 0)
                (quat -2.868731 6.947688 18.876476 10.386089)))
      (o (dqid)))
  (is (dqsclerp! o d1 d2 0.5) r)
  (is o r)
  (is (dqsclerp d1 d2 0.5) r)
  (is (dqsclerp d1 d2 0.0) d1)
  (ok (dq~ (dqsclerp d1 d2 1.0) d2 :tolerance 1e-4)))

(diag "normalized linear interpolation")
(let ((d1 (dquat (quat 0.8660254 0.5 0 0)
                 (quat -2.0669873 4.580127 16.160254 7.9903812)))
      (d2 (dquat (quat 0.9238795 0.38268346 0 0)
                 (quat -3.3648949 9.430137 21.511862 12.737339)))
      (r (dquat (quat 0.8949524 0.44134173 0 0)
                (quat -2.715941 7.0051317 18.836058 10.36386)))
      (o (dqid)))
  (is (dqnlerp! o d1 d2 0.5) r)
  (is o r)
  (is (dqnlerp d1 d2 0.5) r)
  (is (dqnlerp d1 d2 0.0) d1)
  (is (dqnlerp d1 d2 1.0) d2))

(finalize)
