(in-package #:%mfiano.graphics.image.color)

;;; Helpers.

(defmacro with-convert ((from to) &body body)
  `(with-pool-colors (,@(butlast (rest (car body))))
     ,@(loop :with last := (first (last (car body)))
             :for (x y) :on (car body) :by #'cdr
             :for first := from :then nil
             :unless (or (eq x last) (eq y last))
               :collect `(%convert-color ,(if first from x) ,y)
             :when (and y (eq y last))
               :collect `(%convert-color ,x ,to))))

(defun get-rgb-transform (from to illuminant-name)
  (let* ((transforms (base:rgb-transforms base:*context*))
         (from-space (space-name from))
         (to-space (space-name to))
         (key (list from-space to-space illuminant-name)))
    (declare (dynamic-extent key))
    (labels ((make-vector (x y)
               (let ((x (/ x y))
                     (z (/ (- 1 x y) y)))
                 (declare (u:f64 x z))
                 (v3:vec x 1 z)))
             (calculate-rgb-transform (rgb-space)
               (destructuring-bind ((rx ry) (gx gy) (bx by)) (coords rgb-space)
                 (declare (u:f64 rx ry gx gy bx by))
                 (let* ((r (make-vector rx ry))
                        (g (make-vector gx gy))
                        (b (make-vector bx by))
                        (scale (m3:*v3 (m3:invert (m3:mat r g b))
                                       (get-white-point illuminant-name))))
                   (m3:mat (v3:scale r (v3:x scale))
                           (v3:scale g (v3:y scale))
                           (v3:scale b (v3:z scale))))))
             (calculate-transform ()
               (etypecase from
                 (rgb (calculate-rgb-transform from))
                 (xyz (m3:invert (calculate-rgb-transform to))))))
      (declare (inline make-vector calculate-transform))
      (u:if-found (transform (u:href transforms key))
        transform
        (setf (u:href transforms (copy-list key)) (calculate-transform))))))

(declaim (inline get-rgb-hue-properties))
(defun get-rgb-hue-properties (rgb)
  (let ((rgb-channels (channels rgb)))
    (declare (v3:vec rgb-channels))
    (v3:with-components ((rgb- rgb-channels))
      (let* ((min (min rgb-x rgb-y rgb-z))
             (max (max rgb-x rgb-y rgb-z))
             (delta (- max min)))
        (values
         (cond
           ((zerop delta)
            0d0)
           ((= rgb-x max)
            (* (mod (/ (- rgb-y rgb-z) delta) 6d0) 60d0))
           ((= rgb-y max)
            (* (+ (/ (- rgb-z rgb-x) delta) 2d0) 60d0))
           (t
            (* (+ (/ (- rgb-x rgb-y) delta) 4d0) 60d0)))
         min
         max
         delta)))))

(declaim (inline get-rgb-from-hue))
(defun get-rgb-from-hue/chroma (hue chroma)
  (let ((x (* chroma (- 1d0 (abs (1- (mod (/ hue 60d0) 2d0)))))))
    (cond
      ((or (zerop hue)
           (< hue 60d0))
       (values chroma x 0d0))
      ((< hue 120d0)
       (values x chroma 0d0))
      ((< hue 180d0)
       (values 0d0 chroma x))
      ((< hue 240d0)
       (values 0d0 x chroma))
      ((< hue 300d0)
       (values x 0d0 chroma))
      ((< hue 360d0)
       (values chroma 0d0 x)))))

;;; Default high-level conversion routines.

(defmethod convert-color ((from color) (to color))
  (%convert-color from to))

(defmethod convert-color ((from color) (to symbol))
  (convert-color from (make-color to)))

;;; Auxiliary high-level conversion routines to handle colors with alpha channels.

(defmethod convert-color :around ((from alpha) (to color))
  (with-pool-color (alpha (type-of from) :space (space-name from) :copy from)
    (when (pre-multiplied-alpha-p from)
      (un-pre-multiply-alpha alpha))
    (call-next-method alpha to)))

(defmethod convert-color :after ((from color) (to alpha))
  (let ((to-channels (channels to))
        (to-index (alpha-index to)))
    (if (typep from 'alpha)
        (setf (aref to-channels to-index) (aref (channels from) (alpha-index from)))
        (setf (aref to-channels to-index) 1d0))
    (when (pre-multiply-alpha to)
      (pre-multiply-alpha to))))

;;; Low level conversion routines.

(defmacro define-conversion ((from to) &body body)
  (u:with-gensyms (graph edge)
    `(let ((,graph (base:color-space-graph base:*context*))
           (,edge '(,from ,to)))
       (unless (graph:has-edge-p ,graph ,edge)
         (graph:add-edge ,graph ,edge))
       (defmethod %convert-color ((from ,from) (to ,to))
         ,@body))))

(define-conversion (hsl rgb)
  (let ((hsl-channels (channels from))
        (rgb-channels (channels to)))
    (v3:with-components ((hsl- hsl-channels)
                         (rgb- rgb-channels))
      (u:mvlet* ((c (* (- 1d0 (abs (1- (* hsl-z 2d0)))) hsl-y))
                 (m (- hsl-z (/ c 2)))
                 (r g b (get-rgb-from-hue/chroma hsl-x c)))
        (copy-illuminant-name from to)
        (setf rgb-x (+ r m)
              rgb-y (+ g m)
              rgb-z (+ b m))
        to))))

(define-conversion (hsv rgb)
  (let ((hsv-channels (channels from))
        (rgb-channels (channels to)))
    (v3:with-components ((hsv- hsv-channels)
                         (rgb- rgb-channels))
      (u:mvlet* ((c (* hsv-y hsv-z))
                 (m (- hsv-z c))
                 (r g b (get-rgb-from-hue/chroma hsv-x c)))
        (copy-illuminant-name from to)
        (setf rgb-x (+ r m)
              rgb-y (+ g m)
              rgb-z (+ b m))
        to))))

(define-conversion (lab lchab)
  (declare (optimize speed))
  (let ((lab-channels (channels from))
        (lch-channels (channels to)))
    (declare (v3:vec lab-channels lch-channels))
    (v3:with-components ((lab- lab-channels)
                         (lch- lch-channels))
      (let ((arctan (atan lab-z lab-y)))
        (copy-illuminant-name from to)
        (setf lch-x lab-x
              lch-y (sqrt (+ (expt lab-y 2) (expt lab-z 2)))
              lch-z (if (plusp arctan)
                        (u:radians->degrees arctan)
                        (+ (u:radians->degrees arctan) 360)))
        to))))

(define-conversion (lab xyz)
  (declare (optimize speed))
  (let ((lab-channels (channels from))
        (xyz-channels (channels to))
        (white-point (get-white-point (illuminant-name from))))
    (declare (v3:vec xyz-channels white-point))
    (v3:with-components ((xyz- xyz-channels)
                         (w white-point))
      (let* ((L (v3:x lab-channels))
             (a (v3:y lab-channels))
             (b (v3:z lab-channels))
             (fy (* (+ L 16) #.(/ 116)))
             (fx (+ (* a #.(/ 500)) fy))
             (fz (- fy (* b #.(/ 200))))
             (fx^3 (expt fx 3))
             (fz^3 (expt fz 3))
             (rx (if (> fx^3 +cie-e+)
                     fx^3
                     (* (- (* fx 116) 16) #.(/ +cie-k+))))
             (ry (if (> L #.(* +cie-k+ +cie-e+))
                     (expt (* (+ L 16) #.(/ 116)) 3)
                     (* L #.(/ +cie-k+))))
             (rz (if (> fz^3 +cie-e+)
                     fz^3
                     (* (- (* fz 116) 16) #.(/ +cie-k+)))))
        (copy-illuminant-name from to)
        (setf xyz-x (* rx wx)
              xyz-y (* ry wy)
              xyz-z (* rz wz))
        to))))

(define-conversion (lchab lab)
  (declare (optimize speed))
  (let ((lch-channels (channels from))
        (lab-channels (channels to)))
    (declare (v3:vec lch-channels lab-channels))
    (v3:with-components ((lch- lch-channels)
                         (lab- lab-channels))
      (let ((h (u:degrees->radians lch-z)))
        (copy-illuminant-name from to)
        (setf lab-x lch-x
              lab-y (* lch-y (cos h))
              lab-z (* lch-y (sin h)))
        to))))

(define-conversion (lchuv luv)
  (declare (optimize speed))
  (let ((lch-channels (channels from))
        (luv-channels (channels to)))
    (declare (v3:vec lch-channels luv-channels))
    (v3:with-components ((lch- lch-channels)
                         (luv- luv-channels))
      (let ((h (u:degrees->radians lch-z)))
        (copy-illuminant-name from to)
        (setf luv-x lch-x
              luv-y (* lch-y (cos h))
              luv-z (* lch-y (sin h)))
        to))))

(define-conversion (luv lchuv)
  (declare (optimize speed))
  (let ((luv-channels (channels from))
        (lch-channels (channels to)))
    (declare (v3:vec luv-channels lch-channels))
    (v3:with-components ((luv- luv-channels)
                         (lch- lch-channels))
      (let ((arctan (atan luv-z luv-y)))
        (copy-illuminant-name from to)
        (setf lch-x luv-x
              lch-y (sqrt (+ (expt luv-y 2) (expt luv-z 2)))
              lch-z (if (plusp arctan)
                        (u:radians->degrees arctan)
                        (+ (u:radians->degrees arctan) 360)))
        to))))

(define-conversion (luv xyz)
  (declare (optimize speed))
  (let ((luv-channels (channels from))
        (xyz-channels (channels to))
        (white-point (get-white-point (illuminant-name from))))
    (declare (v3:vec luv-channels xyz-channels white-point))
    (v3:with-components ((luv- luv-channels)
                         (xyz- xyz-channels)
                         (w white-point))
      (when (zerop luv-x)
        (v3:zero! xyz-channels)
        (return-from %convert-color to))
      (let* ((div (+ wx (* wy 15) (* wz 3)))
             (a (* (1- (/ (* 52 luv-x) (+ luv-y (* 13 luv-x (/ (* wx 4) div))))) #.(/ 3)))
             (y (if (> luv-x #.(* +cie-k+ +cie-e+))
                    (expt (* (+ luv-x 16) #.(/ 116)) 3)
                    (* luv-x #.(/ +cie-k+))))
             (d (* (- (/ (* 39 luv-x) (+ luv-z (* 13 luv-x (/ (* wy 9) div)))) 5) y))
             (-5y (* y -5)))
        (copy-illuminant-name from to)
        (setf xyz-x (/ (- d -5y) (- a -1/3))
              xyz-y y
              xyz-z (+ (* xyz-x a) -5y))
        to))))

(define-conversion (rgb hsl)
  (let ((hsl-channels (channels to)))
    (declare (v3:vec hsl-channels))
    (v3:with-components ((hsl- hsl-channels))
      (u:mvlet* ((h min max delta (get-rgb-hue-properties from))
                 (l (* (+ max min) 0.5d0))
                 (s (if (zerop l) 0d0 (/ delta (- 1d0 (abs (1- (* l 2d0))))))))
        (copy-illuminant-name from to)
        (setf hsl-x h
              hsl-y s
              hsl-z l)
        to))))

(define-conversion (rgb hsv)
  (let ((hsv-channels (channels to)))
    (declare (v3:vec hsv-channels))
    (v3:with-components ((hsv- hsv-channels))
      (u:mvlet ((h min max delta (get-rgb-hue-properties from)))
        (copy-illuminant-name from to)
        (setf hsv-x h
              hsv-y (if (zerop max) 0d0 (/ delta max))
              hsv-z max)
        to))))

(define-conversion (rgb xyz)
  (declare (optimize speed))
  (with-pool-color (rgb (type-of from) :space (space-name from) :copy from)
    (let* ((illuminant-name (illuminant-name rgb))
           (transform (get-rgb-transform rgb to illuminant-name))
           (rgb-channels (v3:zero)))
      (declare (dynamic-extent rgb-channels))
      (linearize-rgb rgb)
      (replace rgb-channels (the (or v3:vec v4:vec) (channels rgb)))
      (m3:*v3! (channels to) transform rgb-channels)
      (setf (%illuminant-name to) illuminant-name)
      to)))

(define-conversion (xyy xyz)
  (declare (optimize speed))
  (let ((xyy-channels (channels from))
        (xyz-channels (channels to)))
    (declare (v3:vec xyy-channels xyz-channels))
    (v3:with-components ((xyy- xyy-channels)
                         (xyz- xyz-channels))
      (copy-illuminant-name from to)
      (if (zerop xyy-y)
          (v3:zero! xyz-channels)
          (setf xyz-x (/ (* xyy-x xyy-z) xyy-y)
                xyz-y xyy-z
                xyz-z (/ (* (- 1 xyy-x xyy-y) xyy-z) xyy-y)))
      to)))

(define-conversion (xyz lab)
  (declare (optimize speed))
  (let* ((lab-channels (channels to))
         (r (v3:/ (channels from) (get-white-point (illuminant-name from))))
         (rx (v3:x r))
         (ry (v3:y r))
         (rz (v3:z r))
         (fx (if (> rx +cie-e+)
                 (expt rx #.(/ 3d0))
                 (* (+ (* +cie-k+ rx) 16) #.(/ 116))))
         (fy (if (> ry +cie-e+)
                 (expt ry #.(/ 3d0))
                 (* (+ (* +cie-k+ ry) 16) #.(/ 116))))
         (fz (if (> rz +cie-e+)
                 (expt rz #.(/ 3d0))
                 (* (+ (* +cie-k+ rz) 16) #.(/ 116)))))
    (declare (v3:vec lab-channels)
             (dynamic-extent r))
    (v3:with-components ((lab- lab-channels))
      (copy-illuminant-name from to)
      (setf lab-x (- (* fy 116) 16)
            lab-y (* (- fx fy) 500)
            lab-z (* (- fy fz) 200))
      to)))

(define-conversion (xyz luv)
  (declare (optimize speed))
  (let ((xyz-channels (channels from))
        (luv-channels (channels to))
        (white-point (get-white-point (illuminant-name from))))
    (declare (v3:vec xyz-channels luv-channels white-point))
    (v3:with-components ((xyz- xyz-channels)
                         (luv- luv-channels)
                         (w white-point))
      (let ((reference-y (/ xyz-y wy))
            (div-uv (+ xyz-x (* xyz-y 15) (* xyz-z 3)))
            (div-w (+ wx (* wy 15) (* wz 3))))
        (copy-illuminant-name from to)
        (if (zerop div-uv)
            (v3:zero! luv-channels)
            (setf luv-x (if (> reference-y +cie-e+)
                            (- (* 116 (expt reference-y #.(/ 3d0))) 16)
                            (* +cie-k+ reference-y))
                  luv-y (* luv-x 13 (- (/ (* xyz-x 4) div-uv) (/ (* wx 4) div-w)))
                  luv-z (* luv-x 13 (- (/ (* xyz-y 9) div-uv) (/ (* wy 9) div-w)))))
        to))))

(define-conversion (xyz rgb)
  (declare (optimize speed))
  (with-pool-color (xyz 'xyz :copy from)
    (let* ((illuminant-name (illuminant-name to))
           (transform (get-rgb-transform xyz to illuminant-name))
           (rgb-channels (v3:zero)))
      (declare (dynamic-extent rgb-channels))
      (adapt-chromaticity xyz illuminant-name)
      (m3:*v3! rgb-channels transform (channels xyz))
      (replace (the (or v3:vec v4:vec) (channels to)) rgb-channels)
      (delinearize-rgb to)
      (setf (%illuminant-name to) illuminant-name)
      to)))

(define-conversion (xyz xyy)
  (declare (optimize speed))
  (let ((xyz-channels (channels from))
        (xyy-channels (channels to)))
    (declare (v3:vec xyz-channels xyy-channels))
    (v3:with-components ((xyz- xyz-channels)
                         (xyy- xyy-channels))
      (let ((x+y+z (+ xyz-x xyz-y xyz-z)))
        (copy-illuminant-name from to)
        (setf xyy-x (if (zerop x+y+z) 0d0 (/ xyz-x x+y+z))
              xyy-y (if (zerop x+y+z) 0d0 (/ xyz-y x+y+z))
              xyy-z xyz-y)
        to))))
